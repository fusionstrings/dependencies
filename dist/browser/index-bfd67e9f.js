import { e as e$2, A as At, r as r$3, s as s$3, i as i$3, a as a$3, b as r$4, n as n$3, t as t$5, o as o$5, c as s$4, d as r$5, f as n$4, l as l$3, g as s$5, h as r$6 } from './dev.index-5cf87dad.js';
import { a as a$4, T as Te } from './fs-5c8ad041.js';
import './generator-09aa8de3.js';
import './url-545baa7c.js';

var e={};Object.defineProperty(e,"__esModule",{value:true});e.declare=declare;function declare(e){return (t,o,n)=>{var s;let a;for(const e of Object.keys(r$2)){var i;if(!t[e]){a=null!=(i=a)?i:copyApiObject(t);a[e]=r$2[e](a);}}return e(null!=(s=a)?s:t,o||{},n)}}const r$2={assertVersion:e=>r=>{throwVersionError(r,e.version);},targets:()=>()=>({}),assumption:()=>()=>{}};function copyApiObject(e){let r=null;if("string"===typeof e.version&&/^7\./.test(e.version)){r=Object.getPrototypeOf(e);!r||has(r,"version")&&has(r,"transform")&&has(r,"template")&&has(r,"types")||(r=null);}return Object.assign({},r,e)}function has(e,r){return Object.prototype.hasOwnProperty.call(e,r)}function throwVersionError(e,r){if("number"===typeof e){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`;}if("string"!==typeof e)throw new Error("Expected string or integer value.");const t=Error.stackTraceLimit;"number"===typeof t&&t<25&&(Error.stackTraceLimit=25);let o;o="7."===r.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${r}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${e}", but was loaded with "${r}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);"number"===typeof t&&(Error.stackTraceLimit=t);throw Object.assign(o,{code:"BABEL_VERSION_UNSUPPORTED",version:r,range:e})}const t$4=e.__esModule;const o$4=e.declare;

var e$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': e,
  __esModule: t$4,
  declare: o$4
});

var s$2="default"in e$1?e:e$1;var i$2={};Object.defineProperty(i$2,"__esModule",{value:true});i$2.default=void 0;var r$1=s$2;function removePlugin(e,s){const i=[];e.forEach(((e,r)=>{const t=Array.isArray(e)?e[0]:e;t===s&&i.unshift(r);}));for(const s of i)e.splice(s,1);}var t$2=(0, r$1.declare)(((e,{isTSX:s,disallowAmbiguousJSXLike:i})=>{e.assertVersion(7);return {name:"syntax-typescript",manipulateOptions(e,r){const{plugins:t}=r;removePlugin(t,"flow");removePlugin(t,"jsx");r.plugins.push(["typescript",{disallowAmbiguousJSXLike:i}],"classProperties");r.plugins.push("objectRestSpread");s&&r.plugins.push("jsx");}}}));i$2.default=t$2;const u$3=i$2.__esModule;

var t$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: u$3,
  'default': i$2
});

var t$1="default"in e$2?At:e$2;var a$1={};Object.defineProperty(a$1,"__esModule",{value:true});a$1.default=annotateAsPure;var n$2=t$1;const{addComment:o$3}=n$2;const s$1="#__PURE__";const isPureAnnotated=({leadingComments:e})=>!!e&&e.some((e=>/[@#]__PURE__/.test(e.value)));function annotateAsPure(e){const t=e.node||e;isPureAnnotated(t)||o$3(t,"leading",s$1);}const d$3=a$1.__esModule;

var a$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: d$3,
  'default': a$1
});

var o$2={};Object.defineProperty(o$2,"__esModule",{value:true});o$2.assertFieldTransformed=assertFieldTransformed;function assertFieldTransformed(e){if(e.node.declare)throw e.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators")}var l$2="default"in r$3?s$3:r$3;var d$2="default"in i$3?a$3:i$3;var c$1="default"in r$4?n$3:r$4;var p$2="default"in n$4?l$3:n$4;var u$2="default"in a$2?a$1:a$2;var f$1={};Object.defineProperty(f$1,"__esModule",{value:true});f$1.buildFieldsInitNodes=buildFieldsInitNodes;f$1.buildPrivateNamesMap=buildPrivateNamesMap;f$1.buildPrivateNamesNodes=buildPrivateNamesNodes;f$1.transformPrivateNamesUsage=transformPrivateNamesUsage;var b$1=l$2;var m$2=d$2;var y$1=c$1;var h$1=p$2;var v$1=u$2;var g$2=o$2;function buildPrivateNamesMap(e){const t=new Map;for(const s of e)if(s.isPrivate()){const{name:e}=s.node.key.id;const i=t.has(e)?t.get(e):{id:s.scope.generateUidIdentifier(e),static:s.node.static,method:!s.isProperty()};s.isClassPrivateMethod()&&("get"===s.node.kind?i.getId=s.scope.generateUidIdentifier(`get_${e}`):"set"===s.node.kind?i.setId=s.scope.generateUidIdentifier(`set_${e}`):"method"===s.node.kind&&(i.methodId=s.scope.generateUidIdentifier(e)));t.set(e,i);}return t}function buildPrivateNamesNodes(e,t,s){const i=[];for(const[r,n]of e){const{static:e,method:a,getId:o,setId:l}=n;const d=o||l;const c=b$1.types.cloneNode(n.id);let p;t?p=b$1.types.callExpression(s.addHelper("classPrivateFieldLooseKey"),[b$1.types.stringLiteral(r)]):e||(p=b$1.types.newExpression(b$1.types.identifier(!a||d?"WeakMap":"WeakSet"),[]));if(p){(0, v$1.default)(p);i.push(b$1.template.statement.ast`var ${c} = ${p}`);}}return i}function privateNameVisitorFactory(e){const t=Object.assign({},e,{Class(e){const{privateNamesMap:i}=this;const r=e.get("body.body");const n=new Map(i);const a=[];for(const e of r){if(!e.isPrivate())continue;const{name:t}=e.node.key.id;n.delete(t);a.push(t);}if(a.length){e.get("body").traverse(s,Object.assign({},this,{redeclared:a}));e.traverse(t,Object.assign({},this,{privateNamesMap:n}));e.skipKey("body");}}});const s=b$1.traverse.visitors.merge([Object.assign({},e),m$2.environmentVisitor]);return t}const P$1=privateNameVisitorFactory({PrivateName(e,{noDocumentAll:t}){const{privateNamesMap:s,redeclared:i}=this;const{node:r,parentPath:n}=e;if(!n.isMemberExpression({property:r})&&!n.isOptionalMemberExpression({property:r}))return;const{name:a}=r.id;s.has(a)&&(i&&i.includes(a)||this.handle(n,t));}});function unshadow(e,t,s){while(null!=(i=t)&&i.hasBinding(e)&&!t.bindingIdentifierEquals(e,s)){var i;t.rename(e);t=t.parent;}}const N$1=privateNameVisitorFactory({BinaryExpression(e){const{operator:t,left:s,right:i}=e.node;if("in"!==t)return;if(!b$1.types.isPrivateName(s))return;const{privateFieldsAsProperties:r,privateNamesMap:n,redeclared:a}=this;const{name:o}=s.id;if(!n.has(o))return;if(a&&a.includes(o))return;unshadow(this.classRef.name,e.scope,this.innerBinding);if(r){const{id:t}=n.get(o);e.replaceWith(b$1.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${i}, ${b$1.types.cloneNode(t)})
      `);return}const{id:l,static:d}=n.get(o);d?e.replaceWith(b$1.template.expression.ast`${i} === ${this.classRef}`):e.replaceWith(b$1.template.expression.ast`${b$1.types.cloneNode(l)}.has(${i})`);}});const I$1={memoise(e,t){const{scope:s}=e;const{object:i}=e.node;const r=s.maybeGenerateMemoised(i);r&&this.memoiser.set(i,r,t);},receiver(e){const{object:t}=e.node;return this.memoiser.has(t)?b$1.types.cloneNode(this.memoiser.get(t)):b$1.types.cloneNode(t)},get(e){const{classRef:t,privateNamesMap:s,file:i,innerBinding:r}=this;const{name:n}=e.node.property.id;const{id:a,static:o,method:l,methodId:d,getId:c,setId:p}=s.get(n);const u=c||p;if(o){const s=l&&!u?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";unshadow(t.name,e.scope,r);return b$1.types.callExpression(i.addHelper(s),[this.receiver(e),b$1.types.cloneNode(t),b$1.types.cloneNode(a)])}if(l){if(u){if(!c&&p){if(i.availableHelper("writeOnlyError"))return b$1.types.sequenceExpression([this.receiver(e),b$1.types.callExpression(i.addHelper("writeOnlyError"),[b$1.types.stringLiteral(`#${n}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.");}return b$1.types.callExpression(i.addHelper("classPrivateFieldGet"),[this.receiver(e),b$1.types.cloneNode(a)])}return b$1.types.callExpression(i.addHelper("classPrivateMethodGet"),[this.receiver(e),b$1.types.cloneNode(a),b$1.types.cloneNode(d)])}return b$1.types.callExpression(i.addHelper("classPrivateFieldGet"),[this.receiver(e),b$1.types.cloneNode(a)])},boundGet(e){this.memoise(e,1);return b$1.types.callExpression(b$1.types.memberExpression(this.get(e),b$1.types.identifier("bind")),[this.receiver(e)])},set(e,t){const{classRef:s,privateNamesMap:i,file:r}=this;const{name:n}=e.node.property.id;const{id:a,static:o,method:l,setId:d,getId:c}=i.get(n);const p=c||d;if(o){const i=l&&!p?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return b$1.types.callExpression(r.addHelper(i),[this.receiver(e),b$1.types.cloneNode(s),b$1.types.cloneNode(a),t])}return l?d?b$1.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),b$1.types.cloneNode(a),t]):b$1.types.sequenceExpression([this.receiver(e),t,b$1.types.callExpression(r.addHelper("readOnlyError"),[b$1.types.stringLiteral(`#${n}`)])]):b$1.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),b$1.types.cloneNode(a),t])},destructureSet(e){const{classRef:t,privateNamesMap:s,file:i}=this;const{name:r}=e.node.property.id;const{id:n,static:a}=s.get(r);if(a){try{var o=i.addHelper("classStaticPrivateFieldDestructureSet");}catch(e){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return b$1.types.memberExpression(b$1.types.callExpression(o,[this.receiver(e),b$1.types.cloneNode(t),b$1.types.cloneNode(n)]),b$1.types.identifier("value"))}return b$1.types.memberExpression(b$1.types.callExpression(i.addHelper("classPrivateFieldDestructureSet"),[this.receiver(e),b$1.types.cloneNode(n)]),b$1.types.identifier("value"))},call(e,t){this.memoise(e,1);return (0, h$1.default)(this.get(e),this.receiver(e),t,false)},optionalCall(e,t){this.memoise(e,1);return (0, h$1.default)(this.get(e),this.receiver(e),t,true)}};const E$1={get(e){const{privateNamesMap:t,file:s}=this;const{object:i}=e.node;const{name:r}=e.node.property.id;return b$1.template.expression`BASE(REF, PROP)[PROP]`({BASE:s.addHelper("classPrivateFieldLooseBase"),REF:b$1.types.cloneNode(i),PROP:b$1.types.cloneNode(t.get(r).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(e){return b$1.types.callExpression(b$1.types.memberExpression(this.get(e),b$1.types.identifier("bind")),[b$1.types.cloneNode(e.node.object)])},simpleSet(e){return this.get(e)},destructureSet(e){return this.get(e)},call(e,t){return b$1.types.callExpression(this.get(e),t)},optionalCall(e,t){return b$1.types.optionalCallExpression(this.get(e),t,true)}};function transformPrivateNamesUsage(e,t,s,{privateFieldsAsProperties:i,noDocumentAll:r,innerBinding:n},a){if(!s.size)return;const o=t.get("body");const l=i?E$1:I$1;(0, y$1.default)(o,P$1,Object.assign({privateNamesMap:s,classRef:e,file:a},l,{noDocumentAll:r,innerBinding:n}));o.traverse(N$1,{privateNamesMap:s,classRef:e,file:a,privateFieldsAsProperties:i,innerBinding:n});}function buildPrivateFieldInitLoose(e,t,s){const{id:i}=s.get(t.node.key.id.name);const r=t.node.value||t.scope.buildUndefinedNode();return b$1.template.statement.ast`
    Object.defineProperty(${e}, ${b$1.types.cloneNode(i)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${r}
    });
  `}function buildPrivateInstanceFieldInitSpec(e,t,s,i){const{id:r}=s.get(t.node.key.id.name);const n=t.node.value||t.scope.buildUndefinedNode();if(!i.availableHelper("classPrivateFieldInitSpec"))return b$1.template.statement.ast`${b$1.types.cloneNode(r)}.set(${e}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${n},
      })`;const a=i.addHelper("classPrivateFieldInitSpec");return b$1.template.statement.ast`${a}(
    ${b$1.types.thisExpression()},
    ${b$1.types.cloneNode(r)},
    {
      writable: true,
      value: ${n}
    },
  )`}function buildPrivateStaticFieldInitSpec(e,t){const s=t.get(e.node.key.id.name);const{id:i,getId:r,setId:n,initAdded:a}=s;const o=r||n;if(!e.isProperty()&&(a||!o))return;if(o){t.set(e.node.key.id.name,Object.assign({},s,{initAdded:true}));return b$1.template.statement.ast`
      var ${b$1.types.cloneNode(i)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${r?r.name:e.scope.buildUndefinedNode()},
        set: ${n?n.name:e.scope.buildUndefinedNode()}
      }
    `}const l=e.node.value||e.scope.buildUndefinedNode();return b$1.template.statement.ast`
    var ${b$1.types.cloneNode(i)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${l}
    };
  `}function buildPrivateMethodInitLoose(e,t,s){const i=s.get(t.node.key.id.name);const{methodId:r,id:n,getId:a,setId:o,initAdded:l}=i;if(l)return;if(r)return b$1.template.statement.ast`
        Object.defineProperty(${e}, ${n}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${r.name}
        });
      `;const d=a||o;if(d){s.set(t.node.key.id.name,Object.assign({},i,{initAdded:true}));return b$1.template.statement.ast`
      Object.defineProperty(${e}, ${n}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${a?a.name:t.scope.buildUndefinedNode()},
        set: ${o?o.name:t.scope.buildUndefinedNode()}
      });
    `}}function buildPrivateInstanceMethodInitSpec(e,t,s,i){const r=s.get(t.node.key.id.name);const{getId:n,setId:a,initAdded:o}=r;if(o)return;const l=n||a;return l?buildPrivateAccessorInitialization(e,t,s,i):buildPrivateInstanceMethodInitalization(e,t,s,i)}function buildPrivateAccessorInitialization(e,t,s,i){const r=s.get(t.node.key.id.name);const{id:n,getId:a,setId:o}=r;s.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));if(!i.availableHelper("classPrivateFieldInitSpec"))return b$1.template.statement.ast`
      ${n}.set(${e}, {
        get: ${a?a.name:t.scope.buildUndefinedNode()},
        set: ${o?o.name:t.scope.buildUndefinedNode()}
      });
    `;const l=i.addHelper("classPrivateFieldInitSpec");return b$1.template.statement.ast`${l}(
    ${b$1.types.thisExpression()},
    ${b$1.types.cloneNode(n)},
    {
      get: ${a?a.name:t.scope.buildUndefinedNode()},
      set: ${o?o.name:t.scope.buildUndefinedNode()}
    },
  )`}function buildPrivateInstanceMethodInitalization(e,t,s,i){const r=s.get(t.node.key.id.name);const{id:n}=r;if(!i.availableHelper("classPrivateMethodInitSpec"))return b$1.template.statement.ast`${n}.add(${e})`;const a=i.addHelper("classPrivateMethodInitSpec");return b$1.template.statement.ast`${a}(
    ${b$1.types.thisExpression()},
    ${b$1.types.cloneNode(n)}
  )`}function buildPublicFieldInitLoose(e,t){const{key:s,computed:i}=t.node;const r=t.node.value||t.scope.buildUndefinedNode();return b$1.types.expressionStatement(b$1.types.assignmentExpression("=",b$1.types.memberExpression(e,s,i||b$1.types.isLiteral(s)),r))}function buildPublicFieldInitSpec(e,t,s){const{key:i,computed:r}=t.node;const n=t.node.value||t.scope.buildUndefinedNode();return b$1.types.expressionStatement(b$1.types.callExpression(s.addHelper("defineProperty"),[e,r||b$1.types.isLiteral(i)?i:b$1.types.stringLiteral(i.name),n]))}function buildPrivateStaticMethodInitLoose(e,t,s,i){const r=i.get(t.node.key.id.name);const{id:n,methodId:a,getId:o,setId:l,initAdded:d}=r;if(d)return;const c=o||l;if(c){i.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));return b$1.template.statement.ast`
      Object.defineProperty(${e}, ${n}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${o?o.name:t.scope.buildUndefinedNode()},
        set: ${l?l.name:t.scope.buildUndefinedNode()}
      })
    `}return b$1.template.statement.ast`
    Object.defineProperty(${e}, ${n}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${a.name}
    });
  `}function buildPrivateMethodDeclaration(e,t,s=false){const i=t.get(e.node.key.id.name);const{id:r,methodId:n,getId:a,setId:o,getterDeclared:l,setterDeclared:d,static:c}=i;const{params:p,body:u,generator:f,async:m}=e.node;const y=a&&!l&&0===p.length;const h=o&&!d&&p.length>0;let v=n;if(y){t.set(e.node.key.id.name,Object.assign({},i,{getterDeclared:true}));v=a;}else if(h){t.set(e.node.key.id.name,Object.assign({},i,{setterDeclared:true}));v=o;}else c&&!s&&(v=r);return b$1.types.functionDeclaration(b$1.types.cloneNode(v),p,u,f,m)}const F$1=b$1.traverse.visitors.merge([{ThisExpression(e,t){t.needsClassRef=true;e.replaceWith(b$1.types.cloneNode(t.classRef));},MetaProperty(e){const t=e.get("meta");const s=e.get("property");const{scope:i}=e;t.isIdentifier({name:"new"})&&s.isIdentifier({name:"target"})&&e.replaceWith(i.buildUndefinedNode());}},m$2.environmentVisitor]);const $={ReferencedIdentifier(e,t){if(e.scope.bindingIdentifierEquals(e.node.name,t.innerBinding)){t.needsClassRef=true;e.node.name=t.classRef.name;}}};function replaceThisContext(e,t,s,i,r,n,a){var o;const l={classRef:t,needsClassRef:false,innerBinding:a};const d=new m$2.default({methodPath:e,constantSuper:n,file:i,refToPreserve:t,getSuperRef:s,getObjectRef(){l.needsClassRef=true;return r||e.node.static?t:b$1.types.memberExpression(t,b$1.types.identifier("prototype"))}});d.replace();(r||e.isProperty())&&e.traverse(F$1,l);null!=(o=l.classRef)&&o.name&&l.classRef.name!==(null==a?void 0:a.name)&&e.traverse($,l);return l.needsClassRef}function buildFieldsInitNodes(e,t,s,i,r,n,a,o,l){let d=false;let c;const p=[];const u=[];const f=[];const m=b$1.types.isIdentifier(t)?()=>t:()=>{var e;null!=(e=c)?e:c=s[0].scope.generateUidIdentifierBasedOnNode(t);return c};for(const t of s){t.isClassProperty()&&g$2.assertFieldTransformed(t);const s=t.node.static;const c=!s;const y=t.isPrivate();const h=!y;const v=t.isProperty();const P=!v;const N=null==t.isStaticBlock?void 0:t.isStaticBlock();if(s||P&&y||N){const s=replaceThisContext(t,e,m,r,N,o,l);d=d||s;}switch(true){case N:p.push(b$1.template.statement.ast`(() => ${b$1.types.blockStatement(t.node.body)})()`);break;case s&&y&&v&&a:d=true;p.push(buildPrivateFieldInitLoose(b$1.types.cloneNode(e),t,i));break;case s&&y&&v&&!a:d=true;p.push(buildPrivateStaticFieldInitSpec(t,i));break;case s&&h&&v&&n:d=true;p.push(buildPublicFieldInitLoose(b$1.types.cloneNode(e),t));break;case s&&h&&v&&!n:d=true;p.push(buildPublicFieldInitSpec(b$1.types.cloneNode(e),t,r));break;case c&&y&&v&&a:u.push(buildPrivateFieldInitLoose(b$1.types.thisExpression(),t,i));break;case c&&y&&v&&!a:u.push(buildPrivateInstanceFieldInitSpec(b$1.types.thisExpression(),t,i,r));break;case c&&y&&P&&a:u.unshift(buildPrivateMethodInitLoose(b$1.types.thisExpression(),t,i));f.push(buildPrivateMethodDeclaration(t,i,a));break;case c&&y&&P&&!a:u.unshift(buildPrivateInstanceMethodInitSpec(b$1.types.thisExpression(),t,i,r));f.push(buildPrivateMethodDeclaration(t,i,a));break;case s&&y&&P&&!a:d=true;p.unshift(buildPrivateStaticFieldInitSpec(t,i));f.push(buildPrivateMethodDeclaration(t,i,a));break;case s&&y&&P&&a:d=true;p.unshift(buildPrivateStaticMethodInitLoose(b$1.types.cloneNode(e),t,r,i));f.push(buildPrivateMethodDeclaration(t,i,a));break;case c&&h&&v&&n:u.push(buildPublicFieldInitLoose(b$1.types.thisExpression(),t));break;case c&&h&&v&&!n:u.push(buildPublicFieldInitSpec(b$1.types.thisExpression(),t,r));break;default:throw new Error("Unreachable.")}}return {staticNodes:p.filter(Boolean),instanceNodes:u.filter(Boolean),pureStaticNodes:f.filter(Boolean),wrapClass(t){for(const e of s)e.remove();if(c){t.scope.push({id:b$1.types.cloneNode(c)});t.set("superClass",b$1.types.assignmentExpression("=",c,t.node.superClass));}if(!d)return t;if(t.isClassExpression()){t.scope.push({id:e});t.replaceWith(b$1.types.assignmentExpression("=",b$1.types.cloneNode(e),t.node));}else t.node.id||(t.node.id=e);return t}}}var k$1="default"in r$3?s$3:r$3;var C$1="default"in i$3?a$3:i$3;var x$1="default"in t$5?o$5:t$5;var w$1={};Object.defineProperty(w$1,"__esModule",{value:true});w$1.buildDecoratedClass=buildDecoratedClass;w$1.hasDecorators=hasDecorators;w$1.hasOwnDecorators=hasOwnDecorators;var S$1=k$1;var M$1=C$1;var D$1=x$1;function hasOwnDecorators(e){return !!(e.decorators&&e.decorators.length)}function hasDecorators(e){return hasOwnDecorators(e)||e.body.body.some(hasOwnDecorators)}function prop(e,t){return t?S$1.types.objectProperty(S$1.types.identifier(e),t):null}function method(e,t){return S$1.types.objectMethod("method",S$1.types.identifier(e),[],S$1.types.blockStatement(t))}function takeDecorators(e){let t;e.decorators&&e.decorators.length>0&&(t=S$1.types.arrayExpression(e.decorators.map((e=>e.expression))));e.decorators=void 0;return t}function getKey(e){return e.computed?e.key:S$1.types.isIdentifier(e.key)?S$1.types.stringLiteral(e.key.name):S$1.types.stringLiteral(String(e.key.value))}function extractElementDescriptor(e,t,s){const{node:i,scope:r}=s;const n=s.isClassMethod();if(s.isPrivate())throw s.buildCodeFrameError(`Private ${n?"methods":"fields"} in decorated classes are not supported yet.`);new M$1.default({methodPath:s,objectRef:e,superRef:t,file:this,refToPreserve:e}).replace();const a=[prop("kind",S$1.types.stringLiteral(S$1.types.isClassMethod(i)?i.kind:"field")),prop("decorators",takeDecorators(i)),prop("static",i.static&&S$1.types.booleanLiteral(true)),prop("key",getKey(i))].filter(Boolean);if(S$1.types.isClassMethod(i)){const e=i.computed?null:i.key;S$1.types.toExpression(i);a.push(prop("value",(0, D$1.default)({node:i,id:e,scope:r})||i));}else S$1.types.isClassProperty(i)&&i.value?a.push(method("value",S$1.template.statements.ast`return ${i.value}`)):a.push(prop("value",r.buildUndefinedNode()));s.remove();return S$1.types.objectExpression(a)}function addDecorateHelper(e){try{return e.addHelper("decorate")}catch(e){"BABEL_HELPER_UNKNOWN"===e.code&&(e.message+="\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version.");throw e}}function buildDecoratedClass(e,t,s,i){const{node:r,scope:n}=t;const a=n.generateUidIdentifier("initialize");const o=r.id&&t.isDeclaration();const l=t.isInStrictMode();const{superClass:d}=r;r.type="ClassDeclaration";r.id||(r.id=S$1.types.cloneNode(e));let c;if(d){c=n.generateUidIdentifierBasedOnNode(r.superClass,"super");r.superClass=c;}const p=takeDecorators(r);const u=S$1.types.arrayExpression(s.filter((e=>!e.node.abstract)).map(extractElementDescriptor.bind(i,r.id,c)));const f=S$1.template.expression.ast`
    ${addDecorateHelper(i)}(
      ${p||S$1.types.nullLiteral()},
      function (${a}, ${d?S$1.types.cloneNode(c):null}) {
        ${r}
        return { F: ${S$1.types.cloneNode(r.id)}, d: ${u} };
      },
      ${d}
    )
  `;l||f.arguments[1].body.directives.push(S$1.types.directive(S$1.types.directiveLiteral("use strict")));let b=f;let m="arguments.1.body.body.0";if(o){b=S$1.template.statement.ast`let ${e} = ${f}`;m="declarations.0.init."+m;}return {instanceNodes:[S$1.template.statement.ast`${S$1.types.cloneNode(a)}(this)`],wrapClass(e){e.replaceWith(b);return e.get(m)}}}var O="default"in r$3?s$3:r$3;var j="default"in i$3?a$3:i$3;var U={};Object.defineProperty(U,"__esModule",{value:true});U.extractComputedKeys=extractComputedKeys;U.injectInitialization=injectInitialization$1;var L=O;var B=j;const A$1=L.traverse.visitors.merge([{Super(e){const{node:t,parentPath:s}=e;s.isCallExpression({callee:t})&&this.push(s);}},B.environmentVisitor]);const R={"TSTypeAnnotation|TypeAnnotation"(e){e.skip();},ReferencedIdentifier(e){if(this.scope.hasOwnBinding(e.node.name)){this.scope.rename(e.node.name);e.skip();}}};function handleClassTDZ(e,t){if(t.classBinding&&t.classBinding===e.scope.getBinding(e.node.name)){const s=t.file.addHelper("classNameTDZError");const i=L.types.callExpression(s,[L.types.stringLiteral(e.node.name)]);e.replaceWith(L.types.sequenceExpression([i,e.node]));e.skip();}}const _={ReferencedIdentifier:handleClassTDZ};function injectInitialization$1(e,t,s,i){if(!s.length)return;const r=!!e.node.superClass;if(!t){const s=L.types.classMethod("constructor",L.types.identifier("constructor"),[],L.types.blockStatement([]));if(r){s.params=[L.types.restElement(L.types.identifier("args"))];s.body.body.push(L.template.statement.ast`super(...args)`);}[t]=e.get("body").unshiftContainer("body",s);}i&&i(R,{scope:t.scope});if(r){const e=[];t.traverse(A$1,e);let i=true;for(const t of e)if(i){t.insertAfter(s);i=false;}else t.insertAfter(s.map((e=>L.types.cloneNode(e))));}else t.get("body").unshiftContainer("body",s);}function extractComputedKeys(e,t,s,i){const r=[];const n={classBinding:t.node.id&&t.scope.getBinding(t.node.id.name),file:i};for(const e of s){const s=e.get("key");s.isReferencedIdentifier()?handleClassTDZ(s,n):s.traverse(_,n);const i=e.node;if(!s.isConstantExpression()){const e=t.scope.generateUidIdentifierBasedOnNode(i.key);t.scope.push({id:e,kind:"let"});r.push(L.types.expressionStatement(L.types.assignmentExpression("=",L.types.cloneNode(e),i.key)));i.key=L.types.cloneNode(e);}}return r}var H={};Object.defineProperty(H,"__esModule",{value:true});H.FEATURES=void 0;H.enableFeature=enableFeature$1;H.isLoose=isLoose;H.verifyUsedFeatures=verifyUsedFeatures;var T$1=w$1;const z=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});H.FEATURES=z;const K=new Map([[z.fields,"@babel/plugin-proposal-class-properties"],[z.privateMethods,"@babel/plugin-proposal-private-methods"],[z.privateIn,"@babel/plugin-proposal-private-property-in-object"]]);const W="@babel/plugin-class-features/featuresKey";const G="@babel/plugin-class-features/looseKey";const q="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function enableFeature$1(e,t,s){if(!hasFeature(e,t)||canIgnoreLoose(e,t)){e.set(W,e.get(W)|t);if("#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"===s){setLoose(e,t,true);e.set(q,e.get(q)|t);}else if("#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"===s){setLoose(e,t,false);e.set(q,e.get(q)|t);}else setLoose(e,t,s);}let i;let r;for(const[t,s]of K){if(!hasFeature(e,t))continue;const n=isLoose(e,t);if(!canIgnoreLoose(e,t)){if(i===!n)throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");i=n;r=s;}}if(void 0!==i)for(const[t,s]of K)if(hasFeature(e,t)&&isLoose(e,t)!==i){setLoose(e,t,i);console.warn(`Though the "loose" option was set to "${!i}" in your @babel/preset-env config, it will not be used for ${s} since the "loose" mode option was set to "${i}" for ${r}.\nThe "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${s}", { "loose": ${i} }]\nto the "plugins" section of your Babel config.`);}}function hasFeature(e,t){return !!(e.get(W)&t)}function isLoose(e,t){return !!(e.get(G)&t)}function setLoose(e,t,s){s?e.set(G,e.get(G)|t):e.set(G,e.get(G)&~t);e.set(q,e.get(q)&~t);}function canIgnoreLoose(e,t){return !!(e.get(q)&t)}function verifyUsedFeatures(e,t){if((0, T$1.hasOwnDecorators)(e.node)){if(!hasFeature(t,z.decorators))throw e.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n\t["@babel/plugin-proposal-class-properties", { "loose": true }]');if(e.isPrivate())throw e.buildCodeFrameError(`Private ${e.isClassMethod()?"methods":"fields"} in decorated classes are not supported yet.`)}if(null!=e.isClassPrivateMethod&&e.isClassPrivateMethod()&&!hasFeature(t,z.privateMethods))throw e.buildCodeFrameError("Class private methods are not enabled.");if(e.isPrivateName()&&e.parentPath.isBinaryExpression({operator:"in",left:e.node})&&!hasFeature(t,z.privateIn))throw e.buildCodeFrameError("Private property in checks are not enabled.");if(e.isProperty()&&!hasFeature(t,z.fields))throw e.buildCodeFrameError("Class fields are not enabled.");if(null!=e.isStaticBlock&&e.isStaticBlock()&&!hasFeature(t,z.staticBlocks))throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.")}var V$1="default"in r$3?s$3:r$3;var Z="default"in t$5?o$5:t$5;var Y="default"in s$4?r$5:s$4;var J={};Object.defineProperty(J,"__esModule",{value:true});Object.defineProperty(J,"FEATURES",{enumerable:true,get:function(){return re.FEATURES}});J.createClassFeaturePlugin=createClassFeaturePlugin;Object.defineProperty(J,"enableFeature",{enumerable:true,get:function(){return re.enableFeature}});Object.defineProperty(J,"injectInitialization",{enumerable:true,get:function(){return ie.injectInitialization}});var Q=V$1;var X=Z;var ee=Y;var te=f$1;var se=w$1;var ie=U;var re=H;var ne=o$2;const ae="7.16.0".split(".").reduce(((e,t)=>1e5*e+ +t),0);const oe="@babel/plugin-class-features/version";function createClassFeaturePlugin({name:e,feature:t,loose:s,manipulateOptions:i,api:r={assumption:()=>{}}}){const n=r.assumption("setPublicClassFields");const a=r.assumption("privateFieldsAsProperties");const o=r.assumption("constantSuper");const l=r.assumption("noDocumentAll");if(true===s){const t=[];void 0!==n&&t.push('"setPublicClassFields"');void 0!==a&&t.push('"privateFieldsAsProperties"');0!==t.length&&console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value for the ${t.join(" and ")} assumption${t.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsProperties": true\n\t}`);}return {name:e,manipulateOptions:i,pre(){(0, re.enableFeature)(this.file,t,s);(!this.file.get(oe)||this.file.get(oe)<ae)&&this.file.set(oe,ae);},visitor:{Class(e,s){if(this.file.get(oe)!==ae)return;(0, re.verifyUsedFeatures)(e,this.file);e.isClassDeclaration()&&(0, ne.assertFieldTransformed)(e);const i=(0, re.isLoose)(this.file,t);let r;const d=(0, se.hasDecorators)(e.node);const c=[];const p=[];const u=[];const f=new Set;const b=e.get("body");for(const e of b.get("body")){(0, re.verifyUsedFeatures)(e,this.file);(e.isClassProperty()||e.isClassMethod())&&e.node.computed&&u.push(e);if(e.isPrivate()){const{name:t}=e.node.key.id;const s=`get ${t}`;const i=`set ${t}`;if(e.isClassPrivateMethod()){if("get"===e.node.kind){if(f.has(s)||f.has(t)&&!f.has(i))throw e.buildCodeFrameError("Duplicate private field");f.add(s).add(t);}else if("set"===e.node.kind){if(f.has(i)||f.has(t)&&!f.has(s))throw e.buildCodeFrameError("Duplicate private field");f.add(i).add(t);}}else {if(f.has(t)&&!f.has(s)&&!f.has(i)||f.has(t)&&(f.has(s)||f.has(i)))throw e.buildCodeFrameError("Duplicate private field");f.add(t);}}if(e.isClassMethod({kind:"constructor"}))r=e;else {p.push(e);(e.isProperty()||e.isPrivate()||null!=e.isStaticBlock&&e.isStaticBlock())&&c.push(e);}}if(!c.length&&!d)return;const m=e.node.id;let y;if(!m||e.isClassExpression()){(0, X.default)(e);y=e.scope.generateUidIdentifier("class");}else y=Q.types.cloneNode(e.node.id);const h=(0, te.buildPrivateNamesMap)(c);const v=(0, te.buildPrivateNamesNodes)(h,null!=a?a:i,s);(0, te.transformPrivateNamesUsage)(y,e,h,{privateFieldsAsProperties:null!=a?a:i,noDocumentAll:l,innerBinding:m},s);let g,P,N,I,E;if(d){P=I=g=[];({instanceNodes:N,wrapClass:E}=(0, se.buildDecoratedClass)(y,e,p,this.file));}else {g=(0, ie.extractComputedKeys)(y,e,u,this.file);({staticNodes:P,pureStaticNodes:I,instanceNodes:N,wrapClass:E}=(0, te.buildFieldsInitNodes)(y,e.node.superClass,c,h,s,null!=n?n:i,null!=a?a:i,null!=o?o:i,m));}N.length>0&&(0, ie.injectInitialization)(e,r,N,((e,t)=>{if(!d)for(const s of c)s.node.static||s.traverse(e,t);}));const F=E(e);F.insertBefore([...v,...g]);P.length>0&&F.insertAfter(P);I.length>0&&F.find((e=>e.isStatement()||e.isDeclaration())).insertAfter(I);},PrivateName(e){if(this.file.get(oe)===ae&&!e.parentPath.isPrivate({key:e.node}))throw e.buildCodeFrameError(`Unknown PrivateName "${e}"`)},ExportDefaultDeclaration(e){if(this.file.get(oe)!==ae)return;const t=e.get("declaration");t.isClassDeclaration()&&(0, se.hasDecorators)(t.node)&&(t.node.id?(0, ee.default)(e):t.node.type="ClassExpression");}}}}const le=J.__esModule,de=J.FEATURES,ce=J.enableFeature,pe=J.injectInitialization;const ue=J.createClassFeaturePlugin;

var n$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  FEATURES: de,
  __esModule: le,
  createClassFeaturePlugin: ue,
  'default': J,
  enableFeature: ce,
  injectInitialization: pe
});

var i$1="default"in a$4?Te:a$4;var o$1="default"in r$3?s$3:r$3;var s={};Object.defineProperty(s,"__esModule",{value:true});s.default=transpileEnum;s.translateEnumValues=translateEnumValues;var l$1=i$1;var c=o$1;function transpileEnum(e,t){const{node:r}=e;if(r.declare){e.remove();return}const n=r.id.name;const a=enumFill(e,t,r.id);switch(e.parent.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":e.insertAfter(a);if(seen(e.parentPath))e.remove();else {const n=t.isProgram(e.parent);e.scope.registerDeclaration(e.replaceWith(makeVar(r.id,t,n?"var":"let"))[0]);}break;default:throw new Error(`Unexpected enum parent '${e.parent.type}`)}function seen(e){if(e.isExportDeclaration())return seen(e.parentPath);if(e.getData(n))return true;e.setData(n,true);return false}}function makeVar(e,t,r){return t.variableDeclaration(r,[t.variableDeclarator(e)])}const p$1=(0, c.template)("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");const d$1=(0, c.template)('\n  ENUM["NAME"] = VALUE;\n');const u$1=(0, c.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n');const buildEnumMember=(e,t)=>(e?d$1:u$1)(t);function enumFill(e,t,r){const n=translateEnumValues(e,t);const a=n.map((([e,n])=>buildEnumMember(t.isStringLiteral(n),{ENUM:t.cloneNode(r),NAME:e,VALUE:n})));return p$1({ID:t.cloneNode(r),ASSIGNMENTS:a})}function translateEnumValues(e,t){const r=new Map;let n=-1;let a;return e.node.members.map((i=>{const o=t.isIdentifier(i.id)?i.id.name:i.id.value;const s=i.initializer;let c;if(s){n=evaluate(s,r);if(void 0!==n){r.set(o,n);if("number"===typeof n)c=t.numericLiteral(n);else {l$1("string"===typeof n);c=t.stringLiteral(n);}}else c=s;}else if("number"===typeof n){n+=1;c=t.numericLiteral(n);r.set(o,n);}else {if("string"===typeof n)throw e.buildCodeFrameError("Enum member must have initializer.");{const r=t.memberExpression(t.cloneNode(e.node.id),t.stringLiteral(a),true);c=t.binaryExpression("+",t.numericLiteral(1),r);}}a=o;return [o,c]}))}function evaluate(e,t){return evalConstant(e);function evalConstant(e){switch(e.type){case"StringLiteral":return e.value;case"UnaryExpression":return evalUnaryExpression(e);case"BinaryExpression":return evalBinaryExpression(e);case"NumericLiteral":return e.value;case"ParenthesizedExpression":return evalConstant(e.expression);case"Identifier":return t.get(e.name);case"TemplateLiteral":if(1===e.quasis.length)return e.quasis[0].value.cooked;default:return}}function evalUnaryExpression({argument:e,operator:t}){const r=evalConstant(e);if(void 0!==r)switch(t){case"+":return r;case"-":return -r;case"~":return ~r;default:return}}function evalBinaryExpression(e){const t=evalConstant(e.left);if(void 0===t)return;const r=evalConstant(e.right);if(void 0!==r)switch(e.operator){case"|":return t|r;case"&":return t&r;case">>":return t>>r;case">>>":return t>>>r;case"<<":return t<<r;case"^":return t^r;case"*":return t*r;case"/":return t/r;case"+":return t+r;case"-":return t-r;case"%":return t%r;default:return}}}var m$1={};Object.defineProperty(m$1,"__esModule",{value:true});m$1.default=transpileConstEnum;var f=s;function transpileConstEnum(e,t){const{name:r}=e.node.id;const n=e.parentPath.isExportNamedDeclaration();let a=n;!a&&t.isProgram(e.parent)&&(a=e.parent.body.some((e=>t.isExportNamedDeclaration(e)&&!e.source&&e.specifiers.some((e=>t.isExportSpecifier(e)&&e.local.name===r)))));const i=(0, f.translateEnumValues)(e,t);if(a){const a=t.objectExpression(i.map((([e,r])=>t.objectProperty(t.isValidIdentifier(e)?t.identifier(e):t.stringLiteral(e),r))));if(e.scope.hasOwnBinding(r))(n?e.parentPath:e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"),t.identifier("assign")),[e.node.id,a])));else {e.replaceWith(t.variableDeclaration("var",[t.variableDeclarator(e.node.id,a)]));e.scope.registerDeclaration(e);}return}const o=new Map(i);e.scope.path.traverse({Scope(e){e.scope.hasOwnBinding(r)&&e.skip();},MemberExpression(e){if(!t.isIdentifier(e.node.object,{name:r}))return;let n;if(e.node.computed){if(!t.isStringLiteral(e.node.property))return;n=e.node.property.value;}else {if(!t.isIdentifier(e.node.property))return;n=e.node.property.name;}o.has(n)&&e.replaceWith(t.cloneNode(o.get(n)));}});e.remove();}var y="default"in r$3?s$3:r$3;var b={};Object.defineProperty(b,"__esModule",{value:true});b.default=transpileNamespace;var g$1=y;function transpileNamespace(e,t,r){if(e.node.declare||"StringLiteral"===e.node.id.type){e.remove();return}if(!r)throw e.hub.file.buildCodeFrameError(e.node.id,"Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const n=e.node.id.name;const a=handleNested(e,t,t.cloneDeep(e.node));const i=e.scope.hasOwnBinding(n);if("ExportNamedDeclaration"===e.parent.type)if(i)e.parentPath.replaceWith(a);else {e.parentPath.insertAfter(a);e.replaceWith(getDeclaration(t,n));e.scope.registerDeclaration(e.parentPath);}else i?e.replaceWith(a):e.scope.registerDeclaration(e.replaceWithMultiple([getDeclaration(t,n),a])[0]);}function getDeclaration(e,t){return e.variableDeclaration("let",[e.variableDeclarator(e.identifier(t))])}function getMemberExpression(e,t,r){return e.memberExpression(e.identifier(t),e.identifier(r))}function handleVariableDeclaration(e,t,r){if("const"!==e.kind)throw r.file.buildCodeFrameError(e,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations:n}=e;if(n.every((e=>g$1.types.isIdentifier(e.id)))){for(const e of n)e.init=g$1.types.assignmentExpression("=",getMemberExpression(g$1.types,t,e.id.name),e.init);return [e]}const a=g$1.types.getBindingIdentifiers(e);const i=[];for(const e in a)i.push(g$1.types.assignmentExpression("=",getMemberExpression(g$1.types,t,e),g$1.types.cloneNode(a[e])));return [e,g$1.types.expressionStatement(g$1.types.sequenceExpression(i))]}function buildNestedAmbiendModuleError(e,t){throw e.hub.buildError(t,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function handleNested(e,t,r,n){const a=new Set;const i=r.id;t.assertIdentifier(i);const o=e.scope.generateUid(i.name);const s=t.isTSModuleBlock(r.body)?r.body.body:[t.exportNamedDeclaration(r.body)];for(let r=0;r<s.length;r++){const n=s[r];switch(n.type){case"TSModuleDeclaration":{if(!t.isIdentifier(n.id))throw buildNestedAmbiendModuleError(e,n);const i=handleNested(e,t,n);const o=n.id.name;if(a.has(o))s[r]=i;else {a.add(o);s.splice(r++,1,getDeclaration(t,o),i);}continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":a.add(n.id.name);continue;case"VariableDeclaration":for(const e in t.getBindingIdentifiers(n))a.add(e);continue;default:continue;case"ExportNamedDeclaration":}switch(n.declaration.type){case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":{const e=n.declaration.id.name;a.add(e);s.splice(r++,1,n.declaration,t.expressionStatement(t.assignmentExpression("=",getMemberExpression(t,o,e),t.identifier(e))));break}case"VariableDeclaration":{const t=handleVariableDeclaration(n.declaration,o,e.hub);s.splice(r,t.length,...t);r+=t.length-1;break}case"TSModuleDeclaration":{if(!t.isIdentifier(n.declaration.id))throw buildNestedAmbiendModuleError(e,n.declaration);const i=handleNested(e,t,n.declaration,t.identifier(o));const l=n.declaration.id.name;if(a.has(l))s[r]=i;else {a.add(l);s.splice(r++,1,getDeclaration(t,l),i);}}}}let l=t.objectExpression([]);if(n){const e=t.memberExpression(n,i);l=g$1.template.expression.ast`
      ${t.cloneNode(e)} ||
        (${t.cloneNode(e)} = ${l})
    `;}return g$1.template.statement.ast`
    (function (${t.identifier(o)}) {
      ${s}
    })(${i} || (${t.cloneNode(i)} = ${l}));
  `}var h="default"in e$1?e:e$1;var v="default"in t$3?i$2:t$3;var E="default"in r$3?s$3:r$3;var x="default"in n$1?J:n$1;var D={};Object.defineProperty(D,"__esModule",{value:true});D.default=void 0;var T=h;var S=v;var N=E;var P=x;var w=m$1;var I=s;var M=b;function isInType(e){switch(e.parent.type){case"TSTypeReference":case"TSQualifiedName":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return true;case"ExportSpecifier":return "type"===e.parentPath.parent.exportKind;default:return false}}const C=new WeakMap;const A=new WeakMap;const F=new WeakSet;function isGlobalType(e,t){const r=e.find((e=>e.isProgram())).node;if(e.scope.hasOwnBinding(t))return false;if(C.get(r).has(t))return true;console.warn(`The exported identifier "${t}" is not declared in Babel's scope tracker\nas a JavaScript value binding, and "@babel/plugin-transform-typescript"\nnever encountered it as a TypeScript type declaration.\nIt will be treated as a JavaScript value.\n\nThis problem is likely caused by another plugin injecting\n"${t}" without registering it in the scope tracker. If you are the author\n of that plugin, please use "scope.registerDeclaration(declarationPath)".`);return false}function registerGlobalType(e,t){C.get(e).add(t);}var k=(0, T.declare)(((e,t)=>{e.assertVersion(7);const r=/\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;const{allowNamespaces:n=true,jsxPragma:a="React.createElement",jsxPragmaFrag:i="React.Fragment",onlyRemoveTypeImports:o=false,optimizeConstEnums:s=false}=t;var{allowDeclareFields:l=false}=t;const c={field(e){const{node:t}=e;if(!l&&t.declare)throw e.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(t.declare){if(t.value)throw e.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");t.decorators||e.remove();}else if(t.definite){if(t.value)throw e.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");l||t.decorators||e.remove();}else l||t.value||t.decorators||N.types.isClassPrivateProperty(t)||e.remove();t.accessibility&&(t.accessibility=null);t.abstract&&(t.abstract=null);t.readonly&&(t.readonly=null);t.optional&&(t.optional=null);t.typeAnnotation&&(t.typeAnnotation=null);t.definite&&(t.definite=null);t.declare&&(t.declare=null);t.override&&(t.override=null);},method({node:e}){e.accessibility&&(e.accessibility=null);e.abstract&&(e.abstract=null);e.optional&&(e.optional=null);e.override&&(e.override=null);},constructor(e,t){e.node.accessibility&&(e.node.accessibility=null);const r=[];for(const t of e.node.params)if("TSParameterProperty"===t.type&&!F.has(t.parameter)){F.add(t.parameter);r.push(t.parameter);}if(r.length){const n=r.map((t=>{let r;if(N.types.isIdentifier(t))r=t;else {if(!N.types.isAssignmentPattern(t)||!N.types.isIdentifier(t.left))throw e.buildCodeFrameError("Parameter properties can not be destructuring patterns.");r=t.left;}return N.template.statement.ast`
              this.${N.types.cloneNode(r)} = ${N.types.cloneNode(r)}`}));(0, P.injectInitialization)(t,e,n);}}};return {name:"transform-typescript",inherits:S.default,visitor:{Pattern:visitPattern,Identifier:visitPattern,RestElement:visitPattern,Program:{enter(e,t){const{file:n}=t;let s=null;let l=null;const c=e.node;C.has(c)||C.set(c,new Set);if(n.ast.comments)for(const e of n.ast.comments){const t=r.exec(e.value);t&&(t[1]?l=t[2]:s=t[2]);}let p=s||a;p&&([p]=p.split("."));let d=l||i;d&&([d]=d.split("."));for(let r of e.get("body"))if(r.isImportDeclaration()){A.has(t.file.ast.program)||A.set(t.file.ast.program,true);if("type"===r.node.importKind){for(const e of r.node.specifiers)registerGlobalType(c,e.local.name);r.remove();continue}const n=new Set;const a=r.node.specifiers.length;const isAllSpecifiersElided=()=>a>0&&a===n.size;for(const e of r.node.specifiers)if("ImportSpecifier"===e.type&&"type"===e.importKind){registerGlobalType(c,e.local.name);const t=r.scope.getBinding(e.local.name);t&&n.add(t.path);}if(o)A.set(e.node,false);else {if(0===r.node.specifiers.length){A.set(e.node,false);continue}for(const t of r.node.specifiers){const a=r.scope.getBinding(t.local.name);n.has(a.path)||(a&&isImportTypeOnly({binding:a,programPath:e,pragmaImportName:p,pragmaFragImportName:d})?n.add(a.path):A.set(e.node,false));}}if(isAllSpecifiersElided())r.remove();else for(const e of n)e.remove();}else {r.isExportDeclaration()&&(r=r.get("declaration"));if(r.isVariableDeclaration({declare:true}))for(const e of Object.keys(r.getBindingIdentifiers()))registerGlobalType(c,e);else (r.isTSTypeAliasDeclaration()||r.isTSDeclareFunction()&&r.get("id").isIdentifier()||r.isTSInterfaceDeclaration()||r.isClassDeclaration({declare:true})||r.isTSEnumDeclaration({declare:true})||r.isTSModuleDeclaration({declare:true})&&r.get("id").isIdentifier())&&registerGlobalType(c,r.node.id.name);}},exit(e){"module"===e.node.sourceType&&A.get(e.node)&&e.pushContainer("body",N.types.exportNamedDeclaration());}},ExportNamedDeclaration(e,t){A.has(t.file.ast.program)||A.set(t.file.ast.program,true);"type"!==e.node.exportKind?e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every((e=>"ExportSpecifier"===e.type&&"type"===e.exportKind))||!e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every((t=>N.types.isExportSpecifier(t)&&isGlobalType(e,t.local.name)))?e.remove():A.set(t.file.ast.program,false):e.remove();},ExportSpecifier(e){const t=e.parent;(!t.source&&isGlobalType(e,e.node.local.name)||"type"===e.node.exportKind)&&e.remove();},ExportDefaultDeclaration(e,t){A.has(t.file.ast.program)||A.set(t.file.ast.program,true);N.types.isIdentifier(e.node.declaration)&&isGlobalType(e,e.node.declaration.name)?e.remove():A.set(t.file.ast.program,false);},TSDeclareFunction(e){e.remove();},TSDeclareMethod(e){e.remove();},VariableDeclaration(e){e.node.declare&&e.remove();},VariableDeclarator({node:e}){e.definite&&(e.definite=null);},TSIndexSignature(e){e.remove();},ClassDeclaration(e){const{node:t}=e;t.declare&&e.remove();},Class(e){const{node:t}=e;t.typeParameters&&(t.typeParameters=null);t.superTypeParameters&&(t.superTypeParameters=null);t.implements&&(t.implements=null);t.abstract&&(t.abstract=null);e.get("body.body").forEach((t=>{t.isClassMethod()||t.isClassPrivateMethod()?"constructor"===t.node.kind?c.constructor(t,e):c.method(t):(t.isClassProperty()||t.isClassPrivateProperty())&&c.field(t);}));},Function(e){const{node:t,scope:r}=e;t.typeParameters&&(t.typeParameters=null);t.returnType&&(t.returnType=null);const n=t.params;n.length>0&&N.types.isIdentifier(n[0],{name:"this"})&&n.shift();const a=e.get("params");for(const e of a)if("TSParameterProperty"===e.type){e.replaceWith(e.get("parameter"));r.registerBinding("param",e);}},TSModuleDeclaration(e){(0, M.default)(e,N.types,n);},TSInterfaceDeclaration(e){e.remove();},TSTypeAliasDeclaration(e){e.remove();},TSEnumDeclaration(e){s&&e.node.const?(0, w.default)(e,N.types):(0, I.default)(e,N.types);},TSImportEqualsDeclaration(e){if(N.types.isTSExternalModuleReference(e.node.moduleReference))throw e.buildCodeFrameError(`\`import ${e.node.id.name} = require('${e.node.moduleReference.expression.value}')\` is not supported by @babel/plugin-transform-typescript\nPlease consider using \`import ${e.node.id.name} from '${e.node.moduleReference.expression.value}';\` alongside Typescript's --allowSyntheticDefaultImports option.`);e.replaceWith(N.types.variableDeclaration("var",[N.types.variableDeclarator(e.node.id,entityNameToExpr(e.node.moduleReference))]));},TSExportAssignment(e){throw e.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `export <value>;`.")},TSTypeAssertion(e){e.replaceWith(e.node.expression);},TSAsExpression(e){let{node:t}=e;do{t=t.expression;}while(N.types.isTSAsExpression(t));e.replaceWith(t);},TSNonNullExpression(e){e.replaceWith(e.node.expression);},CallExpression(e){e.node.typeParameters=null;},OptionalCallExpression(e){e.node.typeParameters=null;},NewExpression(e){e.node.typeParameters=null;},JSXOpeningElement(e){e.node.typeParameters=null;},TaggedTemplateExpression(e){e.node.typeParameters=null;}}};function entityNameToExpr(e){return N.types.isTSQualifiedName(e)?N.types.memberExpression(entityNameToExpr(e.left),e.right):e}function visitPattern({node:e}){e.typeAnnotation&&(e.typeAnnotation=null);N.types.isIdentifier(e)&&e.optional&&(e.optional=null);}function isImportTypeOnly({binding:e,programPath:t,pragmaImportName:r,pragmaFragImportName:n}){for(const t of e.referencePaths)if(!isInType(t))return false;if(e.identifier.name!==r&&e.identifier.name!==n)return true;let a=false;t.traverse({"JSXElement|JSXFragment"(e){a=true;e.stop();}});return !a}}));D.default=k;const V=D.__esModule;

var a = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: V,
  'default': D
});

var t="default"in e$1?e:e$1;var o="default"in a?D:a;var l="default"in s$5?r$6:s$5;var i={};Object.defineProperty(i,"__esModule",{value:true});var n=t;var r=o;var u=l;function _interopDefaultLegacy(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}var m=_interopDefaultLegacy(r);const p=new u.OptionValidator("@babel/preset-typescript");function normalizeOptions(e={}){let{allowNamespaces:a=true,jsxPragma:s,onlyRemoveTypeImports:t}=e;const o={allExtensions:"allExtensions",allowNamespaces:"allowNamespaces",disallowAmbiguousJSXLike:"disallowAmbiguousJSXLike",isTSX:"isTSX",jsxPragma:"jsxPragma",jsxPragmaFrag:"jsxPragmaFrag",onlyRemoveTypeImports:"onlyRemoveTypeImports",optimizeConstEnums:"optimizeConstEnums"};const l=p.validateStringOption(o.jsxPragmaFrag,e.jsxPragmaFrag,"React.Fragment");const i=p.validateBooleanOption(o.allExtensions,e.allExtensions,false);const n=p.validateBooleanOption(o.isTSX,e.isTSX,false);n&&p.invariant(i,"isTSX:true requires allExtensions:true");const r=p.validateBooleanOption(o.disallowAmbiguousJSXLike,e.disallowAmbiguousJSXLike,false);r&&p.invariant(i,"disallowAmbiguousJSXLike:true requires allExtensions:true");const u=p.validateBooleanOption(o.optimizeConstEnums,e.optimizeConstEnums,false);return {allExtensions:i,allowNamespaces:a,disallowAmbiguousJSXLike:r,isTSX:n,jsxPragma:s,jsxPragmaFrag:l,onlyRemoveTypeImports:t,optimizeConstEnums:u}}var g=n.declare(((e,a)=>{e.assertVersion(7);const{allExtensions:s,allowNamespaces:t,disallowAmbiguousJSXLike:o,isTSX:l,jsxPragma:i,jsxPragmaFrag:n,onlyRemoveTypeImports:r,optimizeConstEnums:u}=normalizeOptions(a);const pluginOptions=(e,s)=>({allowDeclareFields:a.allowDeclareFields,allowNamespaces:t,disallowAmbiguousJSXLike:s,isTSX:e,jsxPragma:i,jsxPragmaFrag:n,onlyRemoveTypeImports:r,optimizeConstEnums:u});return {overrides:s?[{plugins:[[m.default,pluginOptions(l,o)]]}]:[{test:/\.ts$/,plugins:[[m.default,pluginOptions(false,false)]]},{test:/\.mts$/,sourceType:"module",plugins:[[m.default,pluginOptions(false,true)]]},{test:/\.cts$/,sourceType:"script",plugins:[[m.default,pluginOptions(false,true)]]},{test:/\.tsx$/,plugins:[[m.default,pluginOptions(true,false)]]}]}}));i.default=g;const d=i.__esModule;

export { d as __esModule, i as default };
