import { e as e$2, A as At, r as r$5, o as o$8, a as e$3, D as De, b as r$6, s as s$5, t as t$7, c as o$9, d as s$6, f as r$7, g as s$7, i as i$6 } from './dev.index-6dd57f07.js';
import { a as a$6, T as Te } from './fs-fe6d5e4b.js';
import './generator-e7657bbf.js';
import './url-abf489dd.js';
import './2d0a257e-efc2240a.js';
import './153748f5-4b84db7e.js';

var e={};Object.defineProperty(e,"__esModule",{value:true});e.declare=declare;function declare(e){return (t,o,s)=>{var n;let a;for(const e of Object.keys(r$4)){var i;if(!t[e]){a=null!=(i=a)?i:copyApiObject(t);a[e]=r$4[e](a);}}return e(null!=(n=a)?n:t,o||{},s)}}const r$4={assertVersion:e=>r=>{throwVersionError(r,e.version);},targets:()=>()=>({}),assumption:()=>()=>{}};function copyApiObject(e){let r=null;if("string"===typeof e.version&&/^7\./.test(e.version)){r=Object.getPrototypeOf(e);!r||has(r,"version")&&has(r,"transform")&&has(r,"template")&&has(r,"types")||(r=null);}return Object.assign({},r,e)}function has(e,r){return Object.prototype.hasOwnProperty.call(e,r)}function throwVersionError(e,r){if("number"===typeof e){if(!Number.isInteger(e))throw new Error("Expected string or integer value.");e=`^${e}.0.0-0`;}if("string"!==typeof e)throw new Error("Expected string or integer value.");const t=Error.stackTraceLimit;"number"===typeof t&&t<25&&(Error.stackTraceLimit=25);let o;o="7."===r.slice(0,2)?new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${r}". You'll need to update your @babel/core version.`):new Error(`Requires Babel "${e}", but was loaded with "${r}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);"number"===typeof t&&(Error.stackTraceLimit=t);throw Object.assign(o,{code:"BABEL_VERSION_UNSUPPORTED",version:r,range:e})}const t$6=e.__esModule;const o$7=e.declare;

var e$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: t$6,
  declare: o$7,
  'default': e
});

var s$4="default"in e$1?e:e$1;var i$5={};Object.defineProperty(i$5,"__esModule",{value:true});i$5.default=void 0;var r$3=s$4;function removePlugin(e,s){const i=[];e.forEach(((e,r)=>{const t=Array.isArray(e)?e[0]:e;t===s&&i.unshift(r);}));for(const s of i)e.splice(s,1);}var t$4=(0, r$3.declare)(((e,{isTSX:s,disallowAmbiguousJSXLike:i})=>{e.assertVersion(7);return {name:"syntax-typescript",manipulateOptions(e,r){const{plugins:t}=r;removePlugin(t,"flow");removePlugin(t,"jsx");r.plugins.push(["typescript",{disallowAmbiguousJSXLike:i}],"classProperties");r.plugins.push("objectRestSpread");s&&r.plugins.push("jsx");}}}));i$5.default=t$4;const u$6=i$5.__esModule;

var t$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: u$6,
  'default': i$5
});

var t$3="default"in e$2?At:e$2;var n$6={};Object.defineProperty(n$6,"__esModule",{value:true});var s$3=t$3;function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);e&&Object.keys(e).forEach((function(n){if("default"!==n){var s=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,s.get?s:{enumerable:true,get:function(){return e[n]}});}}));t.default=e;return Object.freeze(t)}var i$4=_interopNamespace(s$3);function willPathCastToBoolean(e){const t=e;const{node:n,parentPath:s}=t;if(s.isLogicalExpression()){const{operator:e,right:t}=s.node;if("&&"===e||"||"===e||"??"===e&&n===t)return willPathCastToBoolean(s)}if(s.isSequenceExpression()){const{expressions:e}=s.node;return e[e.length-1]!==n||willPathCastToBoolean(s)}return s.isConditional({test:n})||s.isUnaryExpression({operator:"!"})||s.isLoop({test:n})}const{LOGICAL_OPERATORS:o$6,arrowFunctionExpression:r$2,assignmentExpression:a$4,binaryExpression:l$5,booleanLiteral:p$5,callExpression:c$3,cloneNode:u$5,conditionalExpression:h$3,identifier:d$5,isMemberExpression:f$4,isOptionalCallExpression:m$4,isOptionalMemberExpression:b$3,isUpdateExpression:E$3,logicalExpression:g$4,memberExpression:x$3,nullLiteral:O$2,numericLiteral:P$3,optionalCallExpression:W$1,optionalMemberExpression:y$3,sequenceExpression:C$3,unaryExpression:j$2}=i$4;class AssignmentMemoiser{constructor(){this._map=void 0;this._map=new WeakMap;}has(e){return this._map.has(e)}get(e){if(!this.has(e))return;const t=this._map.get(e);const{value:n}=t;t.count--;return 0===t.count?a$4("=",n,e):n}set(e,t,n){return this._map.set(e,{count:n,value:t})}}function toNonOptional(e,t){const{node:n}=e;if(b$3(n))return x$3(t,n.property,n.computed);if(e.isOptionalCallExpression()){const n=e.get("callee");if(e.node.optional&&n.isOptionalMemberExpression()){const{object:s}=n.node;const i=e.scope.maybeGenerateMemoised(s)||s;n.get("object").replaceWith(a$4("=",i,s));return c$3(x$3(t,d$5("call")),[i,...e.node.arguments])}return c$3(t,e.node.arguments)}return e.node}function isInDetachedTree(e){while(e){if(e.isProgram())break;const{parentPath:t,container:n,listKey:s}=e;const i=t.node;if(s){if(n!==i[s])return true}else if(n!==i)return true;e=t;}return false}const M$3={memoise(){},handle(e,t){const{node:n,parent:s,parentPath:i,scope:x}=e;if(e.isOptionalMemberExpression()){if(isInDetachedTree(e))return;const o=e.find((({node:t,parent:n})=>b$3(n)?n.optional||n.object!==t:!m$4(n)||(t!==e.node&&n.optional||n.callee!==t)));if(x.path.isPattern()){o.replaceWith(c$3(r$2([],o.node),[]));return}const E=willPathCastToBoolean(o);const P=o.parentPath;if(P.isUpdateExpression({argument:n})||P.isAssignmentExpression({left:n}))throw e.buildCodeFrameError("can't handle assignment");const C=P.isUnaryExpression({operator:"delete"});if(C&&o.isOptionalMemberExpression()&&o.get("property").isPrivateName())throw e.buildCodeFrameError("can't delete a private class element");let j=e;for(;;)if(j.isOptionalMemberExpression()){if(j.node.optional)break;j=j.get("object");}else {if(!j.isOptionalCallExpression())throw new Error(`Internal error: unexpected ${j.node.type}`);if(j.node.optional)break;j=j.get("callee");}const M=j.isOptionalMemberExpression()?"object":"callee";const v=j.node[M];const _=x.maybeGenerateMemoised(v);const w=null!=_?_:v;const N=i.isOptionalCallExpression({callee:n});const isOptionalCall=e=>N;const T=i.isCallExpression({callee:n});j.replaceWith(toNonOptional(j,w));isOptionalCall()?s.optional?i.replaceWith(this.optionalCall(e,s.arguments)):i.replaceWith(this.call(e,s.arguments)):T?e.replaceWith(this.boundGet(e)):e.replaceWith(this.get(e));let A=e.node;for(let t=e;t!==o;){const e=t.parentPath;if(e===o&&isOptionalCall()&&s.optional){A=e.node;break}A=toNonOptional(e,A);t=e;}let S;const U=o.parentPath;if(f$4(A)&&U.isOptionalCallExpression({callee:o.node,optional:true})){const{object:t}=A;S=e.scope.maybeGenerateMemoised(t);S&&(A.object=a$4("=",S,t));}let L=o;if(C){L=U;A=U.node;}const k=_?a$4("=",u$5(w),u$5(v)):u$5(w);if(E){let e;e=t?l$5("!=",k,O$2()):g$4("&&",l$5("!==",k,O$2()),l$5("!==",u$5(w),x.buildUndefinedNode()));L.replaceWith(g$4("&&",e,A));}else {let e;e=t?l$5("==",k,O$2()):g$4("||",l$5("===",k,O$2()),l$5("===",u$5(w),x.buildUndefinedNode()));L.replaceWith(h$3(e,C?p$5(true):x.buildUndefinedNode(),A));}if(S){const e=U.node;U.replaceWith(W$1(y$3(e.callee,d$5("call"),false,true),[u$5(S),...e.arguments],false));}}else if(E$3(s,{argument:n})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}const{operator:t,prefix:o}=s;this.memoise(e,2);const r=l$5(t[0],j$2("+",this.get(e)),P$3(1));if(o)i.replaceWith(this.set(e,r));else {const{scope:t}=e;const s=t.generateUidIdentifierBasedOnNode(n);t.push({id:s});r.left=a$4("=",u$5(s),r.left);i.replaceWith(C$3([this.set(e,r),u$5(s)]));}}else if(i.isAssignmentExpression({left:n})){if(this.simpleSet){e.replaceWith(this.simpleSet(e));return}const{operator:t,right:n}=i.node;if("="===t)i.replaceWith(this.set(e,n));else {const s=t.slice(0,-1);if(o$6.includes(s)){this.memoise(e,1);i.replaceWith(g$4(s,this.get(e),this.set(e,n)));}else {this.memoise(e,2);i.replaceWith(this.set(e,l$5(s,this.get(e),n)));}}}else if(i.isCallExpression({callee:n}))i.replaceWith(this.call(e,i.node.arguments));else if(i.isOptionalCallExpression({callee:n})){if(x.path.isPattern()){i.replaceWith(c$3(r$2([],i.node),[]));return}i.replaceWith(this.optionalCall(e,i.node.arguments));}else i.isForXStatement({left:n})||i.isObjectProperty({value:n})&&i.parentPath.isObjectPattern()||i.isAssignmentPattern({left:n})&&i.parentPath.isObjectProperty({value:s})&&i.parentPath.parentPath.isObjectPattern()||i.isArrayPattern()||i.isAssignmentPattern({left:n})&&i.parentPath.isArrayPattern()||i.isRestElement()?e.replaceWith(this.destructureSet(e)):i.isTaggedTemplateExpression()?e.replaceWith(this.boundGet(e)):e.replaceWith(this.get(e));}};function memberExpressionToFunctions(e,t,n){e.traverse(t,Object.assign({},M$3,n,{memoiser:new AssignmentMemoiser}));}n$6.default=memberExpressionToFunctions;const v$3=n$6.__esModule;

var a$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: v$3,
  'default': n$6
});

var a$3="default"in e$2?At:e$2;var l$4={};Object.defineProperty(l$4,"__esModule",{value:true});l$4.default=optimiseCallExpression;var r$1=a$3;const{callExpression:s$2,identifier:t$2,isIdentifier:n$4,isSpreadElement:i$3,memberExpression:o$5,optionalCallExpression:p$4,optionalMemberExpression:u$4}=r$1;function optimiseCallExpression(e,a,l,r){return 1===l.length&&i$3(l[0])&&n$4(l[0].argument,{name:"arguments"})?r?p$4(u$4(e,t$2("apply"),false,true),[a,l[0].argument],false):s$2(o$5(e,t$2("apply")),[a,l[0].argument]):r?p$4(u$4(e,t$2("call"),false,true),[a,...l],false):s$2(o$5(e,t$2("call")),[a,...l])}const f$3=l$4.__esModule;

var n$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: f$3,
  'default': l$4
});

var o$4="default"in e$3?De:e$3;var n$3="default"in a$5?n$6:a$5;var a$2="default"in n$5?l$4:n$5;var p$3="default"in r$5?o$8:r$5;var u$3="default"in e$2?At:e$2;var c$2={};Object.defineProperty(c$2,"__esModule",{value:true});c$2.default=void 0;Object.defineProperty(c$2,"environmentVisitor",{enumerable:true,get:function(){return f$2.default}});Object.defineProperty(c$2,"skipAllButComputedKey",{enumerable:true,get:function(){return f$2.skipAllButComputedKey}});var h$2=o$4;var l$3=n$3;var d$4=a$2;var f$2=p$3;var m$3=u$3;const{assignmentExpression:g$3,booleanLiteral:v$2,callExpression:b$2,cloneNode:S$2,identifier:R$1,memberExpression:P$2,sequenceExpression:y$2,stringLiteral:O$1,thisExpression:j$1}=m$3;function getPrototypeOfExpression(e,t,s,i){e=S$2(e);const r=t||i?e:P$2(e,R$1("prototype"));return b$2(s.addHelper("getPrototypeOf"),[r])}const M$2=h$2.default.visitors.merge([f$2.default,{Super(e,t){const{node:s,parentPath:i}=e;i.isMemberExpression({object:s})&&t.handle(i);}}]);const _$1=h$2.default.visitors.merge([f$2.default,{Scopable(e,{refName:t}){const s=e.scope.getOwnBinding(t);s&&s.identifier.name===t&&e.scope.rename(t);}}]);const x$2={memoise(e,t){const{scope:s,node:i}=e;const{computed:r,property:o}=i;if(!r)return;const n=s.maybeGenerateMemoised(o);n&&this.memoiser.set(o,n,t);},prop(e){const{computed:t,property:s}=e.node;return this.memoiser.has(s)?S$2(this.memoiser.get(s)):t?S$2(s):O$1(s.name)},get(e){return this._get(e,this._getThisRefs())},_get(e,t){const s=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return b$2(this.file.addHelper("get"),[t.memo?y$2([t.memo,s]):s,this.prop(e),t.this])},_getThisRefs(){if(!this.isDerivedConstructor)return {this:j$1()};const e=this.scope.generateDeclaredUidIdentifier("thisSuper");return {memo:g$3("=",e,j$1()),this:S$2(e)}},set(e,t){const s=this._getThisRefs();const i=getPrototypeOfExpression(this.getObjectRef(),this.isStatic,this.file,this.isPrivateMethod);return b$2(this.file.addHelper("set"),[s.memo?y$2([s.memo,i]):i,this.prop(e),t,s.this,v$2(e.isInStrictMode())])},destructureSet(e){throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.")},call(e,t){const s=this._getThisRefs();return (0, d$4.default)(this._get(e,s),S$2(s.this),t,false)},optionalCall(e,t){const s=this._getThisRefs();return (0, d$4.default)(this._get(e,s),S$2(s.this),t,true)}};const C$2=Object.assign({},x$2,{prop(e){const{property:t}=e.node;return this.memoiser.has(t)?S$2(this.memoiser.get(t)):S$2(t)},get(e){const{isStatic:t,getSuperRef:s}=this;const{computed:i}=e.node;const r=this.prop(e);let o;if(t){var n;o=null!=(n=s())?n:P$2(R$1("Function"),R$1("prototype"));}else {var a;o=P$2(null!=(a=s())?a:R$1("Object"),R$1("prototype"));}return P$2(o,r,i)},set(e,t){const{computed:s}=e.node;const i=this.prop(e);return g$3("=",P$2(j$1(),i,s),t)},destructureSet(e){const{computed:t}=e.node;const s=this.prop(e);return P$2(j$1(),s,t)},call(e,t){return (0, d$4.default)(this.get(e),j$1(),t,false)},optionalCall(e,t){return (0, d$4.default)(this.get(e),j$1(),t,true)}});class ReplaceSupers{constructor(e){var t;const s=e.methodPath;this.methodPath=s;this.isDerivedConstructor=s.isClassMethod({kind:"constructor"})&&!!e.superRef;this.isStatic=s.isObjectMethod()||s.node.static||(null==s.isStaticBlock?void 0:s.isStaticBlock());this.isPrivateMethod=s.isPrivate()&&s.isMethod();this.file=e.file;this.constantSuper=null!=(t=e.constantSuper)?t:e.isLoose;this.opts=e;}getObjectRef(){return S$2(this.opts.objectRef||this.opts.getObjectRef())}getSuperRef(){return this.opts.superRef?S$2(this.opts.superRef):this.opts.getSuperRef?S$2(this.opts.getSuperRef()):void 0}replace(){this.opts.refToPreserve&&this.methodPath.traverse(_$1,{refName:this.opts.refToPreserve.name});const e=this.constantSuper?C$2:x$2;(0, l$3.default)(this.methodPath,M$2,Object.assign({file:this.file,scope:this.methodPath.scope,isDerivedConstructor:this.isDerivedConstructor,isStatic:this.isStatic,isPrivateMethod:this.isPrivateMethod,getObjectRef:this.getObjectRef.bind(this),getSuperRef:this.getSuperRef.bind(this),boundGet:e.get},e));}}c$2.default=ReplaceSupers;const E$2=c$2.__esModule,T$2=c$2.environmentVisitor,k$2=c$2.skipAllButComputedKey;

var i$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: E$2,
  'default': c$2,
  environmentVisitor: T$2,
  skipAllButComputedKey: k$2
});

var t$1="default"in e$2?At:e$2;var a$1={};Object.defineProperty(a$1,"__esModule",{value:true});a$1.default=annotateAsPure;var n$2=t$1;const{addComment:o$2}=n$2;const s$1="#__PURE__";const isPureAnnotated=({leadingComments:e})=>!!e&&e.some((e=>/[@#]__PURE__/.test(e.value)));function annotateAsPure(e){const t=e.node||e;isPureAnnotated(t)||o$2(t,"leading",s$1);}const d$3=a$1.__esModule;

var o$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: d$3,
  'default': a$1
});

var l$2={};Object.defineProperty(l$2,"__esModule",{value:true});l$2.assertFieldTransformed=assertFieldTransformed;function assertFieldTransformed(e){if(e.node.declare)throw e.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators")}var d$2="default"in r$6?s$5:r$6;var c$1="default"in i$2?c$2:i$2;var p$2="default"in r$5?o$8:r$5;var u$2="default"in a$5?n$6:a$5;var f$1="default"in n$5?l$4:n$5;var b$1="default"in o$3?a$1:o$3;var m$2={};Object.defineProperty(m$2,"__esModule",{value:true});m$2.buildFieldsInitNodes=buildFieldsInitNodes;m$2.buildPrivateNamesMap=buildPrivateNamesMap;m$2.buildPrivateNamesNodes=buildPrivateNamesNodes;m$2.transformPrivateNamesUsage=transformPrivateNamesUsage;var y$1=d$2;var h$1=c$1;var v$1=p$2;var g$2=u$2;var P$1=f$1;var N$1=b$1;var I$1=l$2;function buildPrivateNamesMap(e){const t=new Map;for(const s of e)if(s.isPrivate()){const{name:e}=s.node.key.id;const i=t.has(e)?t.get(e):{id:s.scope.generateUidIdentifier(e),static:s.node.static,method:!s.isProperty()};s.isClassPrivateMethod()&&("get"===s.node.kind?i.getId=s.scope.generateUidIdentifier(`get_${e}`):"set"===s.node.kind?i.setId=s.scope.generateUidIdentifier(`set_${e}`):"method"===s.node.kind&&(i.methodId=s.scope.generateUidIdentifier(e)));t.set(e,i);}return t}function buildPrivateNamesNodes(e,t,s){const i=[];for(const[r,a]of e){const{static:e,method:n,getId:o,setId:l}=a;const d=o||l;const c=y$1.types.cloneNode(a.id);let p;t?p=y$1.types.callExpression(s.addHelper("classPrivateFieldLooseKey"),[y$1.types.stringLiteral(r)]):e||(p=y$1.types.newExpression(y$1.types.identifier(!n||d?"WeakMap":"WeakSet"),[]));if(p){(0, N$1.default)(p);i.push(y$1.template.statement.ast`var ${c} = ${p}`);}}return i}function privateNameVisitorFactory(e){const t=Object.assign({},e,{Class(e){const{privateNamesMap:i}=this;const r=e.get("body.body");const a=new Map(i);const n=[];for(const e of r){if(!e.isPrivate())continue;const{name:t}=e.node.key.id;a.delete(t);n.push(t);}if(n.length){e.get("body").traverse(s,Object.assign({},this,{redeclared:n}));e.traverse(t,Object.assign({},this,{privateNamesMap:a}));e.skipKey("body");}}});const s=y$1.traverse.visitors.merge([Object.assign({},e),v$1.default]);return t}const E$1=privateNameVisitorFactory({PrivateName(e,{noDocumentAll:t}){const{privateNamesMap:s,redeclared:i}=this;const{node:r,parentPath:a}=e;if(!a.isMemberExpression({property:r})&&!a.isOptionalMemberExpression({property:r}))return;const{name:n}=r.id;s.has(n)&&(i&&i.includes(n)||this.handle(a,t));}});function unshadow(e,t,s){while(null!=(i=t)&&i.hasBinding(e)&&!t.bindingIdentifierEquals(e,s)){var i;t.rename(e);t=t.parent;}}const F$1=privateNameVisitorFactory({BinaryExpression(e){const{operator:t,left:s,right:i}=e.node;if("in"!==t)return;if(!y$1.types.isPrivateName(s))return;const{privateFieldsAsProperties:r,privateNamesMap:a,redeclared:n}=this;const{name:o}=s.id;if(!a.has(o))return;if(n&&n.includes(o))return;unshadow(this.classRef.name,e.scope,this.innerBinding);if(r){const{id:t}=a.get(o);e.replaceWith(y$1.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${i}, ${y$1.types.cloneNode(t)})
      `);return}const{id:l,static:d}=a.get(o);d?e.replaceWith(y$1.template.expression.ast`${i} === ${this.classRef}`):e.replaceWith(y$1.template.expression.ast`${y$1.types.cloneNode(l)}.has(${i})`);}});const $={memoise(e,t){const{scope:s}=e;const{object:i}=e.node;const r=s.maybeGenerateMemoised(i);r&&this.memoiser.set(i,r,t);},receiver(e){const{object:t}=e.node;return this.memoiser.has(t)?y$1.types.cloneNode(this.memoiser.get(t)):y$1.types.cloneNode(t)},get(e){const{classRef:t,privateNamesMap:s,file:i,innerBinding:r}=this;const{name:a}=e.node.property.id;const{id:n,static:o,method:l,methodId:d,getId:c,setId:p}=s.get(a);const u=c||p;if(o){const s=l&&!u?"classStaticPrivateMethodGet":"classStaticPrivateFieldSpecGet";unshadow(t.name,e.scope,r);return y$1.types.callExpression(i.addHelper(s),[this.receiver(e),y$1.types.cloneNode(t),y$1.types.cloneNode(n)])}if(l){if(u){if(!c&&p){if(i.availableHelper("writeOnlyError"))return y$1.types.sequenceExpression([this.receiver(e),y$1.types.callExpression(i.addHelper("writeOnlyError"),[y$1.types.stringLiteral(`#${a}`)])]);console.warn("@babel/helpers is outdated, update it to silence this warning.");}return y$1.types.callExpression(i.addHelper("classPrivateFieldGet"),[this.receiver(e),y$1.types.cloneNode(n)])}return y$1.types.callExpression(i.addHelper("classPrivateMethodGet"),[this.receiver(e),y$1.types.cloneNode(n),y$1.types.cloneNode(d)])}return y$1.types.callExpression(i.addHelper("classPrivateFieldGet"),[this.receiver(e),y$1.types.cloneNode(n)])},boundGet(e){this.memoise(e,1);return y$1.types.callExpression(y$1.types.memberExpression(this.get(e),y$1.types.identifier("bind")),[this.receiver(e)])},set(e,t){const{classRef:s,privateNamesMap:i,file:r}=this;const{name:a}=e.node.property.id;const{id:n,static:o,method:l,setId:d,getId:c}=i.get(a);const p=c||d;if(o){const i=l&&!p?"classStaticPrivateMethodSet":"classStaticPrivateFieldSpecSet";return y$1.types.callExpression(r.addHelper(i),[this.receiver(e),y$1.types.cloneNode(s),y$1.types.cloneNode(n),t])}return l?d?y$1.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),y$1.types.cloneNode(n),t]):y$1.types.sequenceExpression([this.receiver(e),t,y$1.types.callExpression(r.addHelper("readOnlyError"),[y$1.types.stringLiteral(`#${a}`)])]):y$1.types.callExpression(r.addHelper("classPrivateFieldSet"),[this.receiver(e),y$1.types.cloneNode(n),t])},destructureSet(e){const{classRef:t,privateNamesMap:s,file:i}=this;const{name:r}=e.node.property.id;const{id:a,static:n}=s.get(r);if(n){try{var o=i.addHelper("classStaticPrivateFieldDestructureSet");}catch(e){throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.")}return y$1.types.memberExpression(y$1.types.callExpression(o,[this.receiver(e),y$1.types.cloneNode(t),y$1.types.cloneNode(a)]),y$1.types.identifier("value"))}return y$1.types.memberExpression(y$1.types.callExpression(i.addHelper("classPrivateFieldDestructureSet"),[this.receiver(e),y$1.types.cloneNode(a)]),y$1.types.identifier("value"))},call(e,t){this.memoise(e,1);return (0, P$1.default)(this.get(e),this.receiver(e),t,false)},optionalCall(e,t){this.memoise(e,1);return (0, P$1.default)(this.get(e),this.receiver(e),t,true)}};const k$1={get(e){const{privateNamesMap:t,file:s}=this;const{object:i}=e.node;const{name:r}=e.node.property.id;return y$1.template.expression`BASE(REF, PROP)[PROP]`({BASE:s.addHelper("classPrivateFieldLooseBase"),REF:y$1.types.cloneNode(i),PROP:y$1.types.cloneNode(t.get(r).id)})},set(){throw new Error("private name handler with loose = true don't need set()")},boundGet(e){return y$1.types.callExpression(y$1.types.memberExpression(this.get(e),y$1.types.identifier("bind")),[y$1.types.cloneNode(e.node.object)])},simpleSet(e){return this.get(e)},destructureSet(e){return this.get(e)},call(e,t){return y$1.types.callExpression(this.get(e),t)},optionalCall(e,t){return y$1.types.optionalCallExpression(this.get(e),t,true)}};function transformPrivateNamesUsage(e,t,s,{privateFieldsAsProperties:i,noDocumentAll:r,innerBinding:a},n){if(!s.size)return;const o=t.get("body");const l=i?k$1:$;(0, g$2.default)(o,E$1,Object.assign({privateNamesMap:s,classRef:e,file:n},l,{noDocumentAll:r,innerBinding:a}));o.traverse(F$1,{privateNamesMap:s,classRef:e,file:n,privateFieldsAsProperties:i,innerBinding:a});}function buildPrivateFieldInitLoose(e,t,s){const{id:i}=s.get(t.node.key.id.name);const r=t.node.value||t.scope.buildUndefinedNode();return y$1.template.statement.ast`
    Object.defineProperty(${e}, ${y$1.types.cloneNode(i)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${r}
    });
  `}function buildPrivateInstanceFieldInitSpec(e,t,s,i){const{id:r}=s.get(t.node.key.id.name);const a=t.node.value||t.scope.buildUndefinedNode();if(!i.availableHelper("classPrivateFieldInitSpec"))return y$1.template.statement.ast`${y$1.types.cloneNode(r)}.set(${e}, {
        // configurable is always false for private elements
        // enumerable is always false for private elements
        writable: true,
        value: ${a},
      })`;const n=i.addHelper("classPrivateFieldInitSpec");return y$1.template.statement.ast`${n}(
    ${y$1.types.thisExpression()},
    ${y$1.types.cloneNode(r)},
    {
      writable: true,
      value: ${a}
    },
  )`}function buildPrivateStaticFieldInitSpec(e,t){const s=t.get(e.node.key.id.name);const{id:i,getId:r,setId:a,initAdded:n}=s;const o=r||a;if(!e.isProperty()&&(n||!o))return;if(o){t.set(e.node.key.id.name,Object.assign({},s,{initAdded:true}));return y$1.template.statement.ast`
      var ${y$1.types.cloneNode(i)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${r?r.name:e.scope.buildUndefinedNode()},
        set: ${a?a.name:e.scope.buildUndefinedNode()}
      }
    `}const l=e.node.value||e.scope.buildUndefinedNode();return y$1.template.statement.ast`
    var ${y$1.types.cloneNode(i)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${l}
    };
  `}function buildPrivateMethodInitLoose(e,t,s){const i=s.get(t.node.key.id.name);const{methodId:r,id:a,getId:n,setId:o,initAdded:l}=i;if(l)return;if(r)return y$1.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${r.name}
        });
      `;const d=n||o;if(d){s.set(t.node.key.id.name,Object.assign({},i,{initAdded:true}));return y$1.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${n?n.name:t.scope.buildUndefinedNode()},
        set: ${o?o.name:t.scope.buildUndefinedNode()}
      });
    `}}function buildPrivateInstanceMethodInitSpec(e,t,s,i){const r=s.get(t.node.key.id.name);const{getId:a,setId:n,initAdded:o}=r;if(o)return;const l=a||n;return l?buildPrivateAccessorInitialization(e,t,s,i):buildPrivateInstanceMethodInitalization(e,t,s,i)}function buildPrivateAccessorInitialization(e,t,s,i){const r=s.get(t.node.key.id.name);const{id:a,getId:n,setId:o}=r;s.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));if(!i.availableHelper("classPrivateFieldInitSpec"))return y$1.template.statement.ast`
      ${a}.set(${e}, {
        get: ${n?n.name:t.scope.buildUndefinedNode()},
        set: ${o?o.name:t.scope.buildUndefinedNode()}
      });
    `;const l=i.addHelper("classPrivateFieldInitSpec");return y$1.template.statement.ast`${l}(
    ${y$1.types.thisExpression()},
    ${y$1.types.cloneNode(a)},
    {
      get: ${n?n.name:t.scope.buildUndefinedNode()},
      set: ${o?o.name:t.scope.buildUndefinedNode()}
    },
  )`}function buildPrivateInstanceMethodInitalization(e,t,s,i){const r=s.get(t.node.key.id.name);const{id:a}=r;if(!i.availableHelper("classPrivateMethodInitSpec"))return y$1.template.statement.ast`${a}.add(${e})`;const n=i.addHelper("classPrivateMethodInitSpec");return y$1.template.statement.ast`${n}(
    ${y$1.types.thisExpression()},
    ${y$1.types.cloneNode(a)}
  )`}function buildPublicFieldInitLoose(e,t){const{key:s,computed:i}=t.node;const r=t.node.value||t.scope.buildUndefinedNode();return y$1.types.expressionStatement(y$1.types.assignmentExpression("=",y$1.types.memberExpression(e,s,i||y$1.types.isLiteral(s)),r))}function buildPublicFieldInitSpec(e,t,s){const{key:i,computed:r}=t.node;const a=t.node.value||t.scope.buildUndefinedNode();return y$1.types.expressionStatement(y$1.types.callExpression(s.addHelper("defineProperty"),[e,r||y$1.types.isLiteral(i)?i:y$1.types.stringLiteral(i.name),a]))}function buildPrivateStaticMethodInitLoose(e,t,s,i){const r=i.get(t.node.key.id.name);const{id:a,methodId:n,getId:o,setId:l,initAdded:d}=r;if(d)return;const c=o||l;if(c){i.set(t.node.key.id.name,Object.assign({},r,{initAdded:true}));return y$1.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${o?o.name:t.scope.buildUndefinedNode()},
        set: ${l?l.name:t.scope.buildUndefinedNode()}
      })
    `}return y$1.template.statement.ast`
    Object.defineProperty(${e}, ${a}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${n.name}
    });
  `}function buildPrivateMethodDeclaration(e,t,s=false){const i=t.get(e.node.key.id.name);const{id:r,methodId:a,getId:n,setId:o,getterDeclared:l,setterDeclared:d,static:c}=i;const{params:p,body:u,generator:f,async:b}=e.node;const m=n&&!l&&0===p.length;const h=o&&!d&&p.length>0;let v=a;if(m){t.set(e.node.key.id.name,Object.assign({},i,{getterDeclared:true}));v=n;}else if(h){t.set(e.node.key.id.name,Object.assign({},i,{setterDeclared:true}));v=o;}else c&&!s&&(v=r);return y$1.types.functionDeclaration(y$1.types.cloneNode(v),p,u,f,b)}const C$1=y$1.traverse.visitors.merge([{ThisExpression(e,t){t.needsClassRef=true;e.replaceWith(y$1.types.cloneNode(t.classRef));},MetaProperty(e){const t=e.get("meta");const s=e.get("property");const{scope:i}=e;t.isIdentifier({name:"new"})&&s.isIdentifier({name:"target"})&&e.replaceWith(i.buildUndefinedNode());}},v$1.default]);const x$1={ReferencedIdentifier(e,t){if(e.scope.bindingIdentifierEquals(e.node.name,t.innerBinding)){t.needsClassRef=true;e.node.name=t.classRef.name;}}};function replaceThisContext(e,t,s,i,r,a,n){var o;const l={classRef:t,needsClassRef:false,innerBinding:n};const d=new h$1.default({methodPath:e,constantSuper:a,file:i,refToPreserve:t,getSuperRef:s,getObjectRef(){l.needsClassRef=true;return r||e.node.static?t:y$1.types.memberExpression(t,y$1.types.identifier("prototype"))}});d.replace();(r||e.isProperty())&&e.traverse(C$1,l);null!=(o=l.classRef)&&o.name&&l.classRef.name!==(null==n?void 0:n.name)&&e.traverse(x$1,l);return l.needsClassRef}function buildFieldsInitNodes(e,t,s,i,r,a,n,o,l){let d=false;let c;const p=[];const u=[];const f=[];const b=y$1.types.isIdentifier(t)?()=>t:()=>{var e;null!=(e=c)?e:c=s[0].scope.generateUidIdentifierBasedOnNode(t);return c};for(const t of s){t.isClassProperty()&&I$1.assertFieldTransformed(t);const s=t.node.static;const c=!s;const m=t.isPrivate();const h=!m;const v=t.isProperty();const g=!v;const P=null==t.isStaticBlock?void 0:t.isStaticBlock();if(s||g&&m||P){const s=replaceThisContext(t,e,b,r,P,o,l);d=d||s;}switch(true){case P:p.push(y$1.template.statement.ast`(() => ${y$1.types.blockStatement(t.node.body)})()`);break;case s&&m&&v&&n:d=true;p.push(buildPrivateFieldInitLoose(y$1.types.cloneNode(e),t,i));break;case s&&m&&v&&!n:d=true;p.push(buildPrivateStaticFieldInitSpec(t,i));break;case s&&h&&v&&a:d=true;p.push(buildPublicFieldInitLoose(y$1.types.cloneNode(e),t));break;case s&&h&&v&&!a:d=true;p.push(buildPublicFieldInitSpec(y$1.types.cloneNode(e),t,r));break;case c&&m&&v&&n:u.push(buildPrivateFieldInitLoose(y$1.types.thisExpression(),t,i));break;case c&&m&&v&&!n:u.push(buildPrivateInstanceFieldInitSpec(y$1.types.thisExpression(),t,i,r));break;case c&&m&&g&&n:u.unshift(buildPrivateMethodInitLoose(y$1.types.thisExpression(),t,i));f.push(buildPrivateMethodDeclaration(t,i,n));break;case c&&m&&g&&!n:u.unshift(buildPrivateInstanceMethodInitSpec(y$1.types.thisExpression(),t,i,r));f.push(buildPrivateMethodDeclaration(t,i,n));break;case s&&m&&g&&!n:d=true;p.unshift(buildPrivateStaticFieldInitSpec(t,i));f.push(buildPrivateMethodDeclaration(t,i,n));break;case s&&m&&g&&n:d=true;p.unshift(buildPrivateStaticMethodInitLoose(y$1.types.cloneNode(e),t,r,i));f.push(buildPrivateMethodDeclaration(t,i,n));break;case c&&h&&v&&a:u.push(buildPublicFieldInitLoose(y$1.types.thisExpression(),t));break;case c&&h&&v&&!a:u.push(buildPublicFieldInitSpec(y$1.types.thisExpression(),t,r));break;default:throw new Error("Unreachable.")}}return {staticNodes:p.filter(Boolean),instanceNodes:u.filter(Boolean),pureStaticNodes:f.filter(Boolean),wrapClass(t){for(const e of s)e.remove();if(c){t.scope.push({id:y$1.types.cloneNode(c)});t.set("superClass",y$1.types.assignmentExpression("=",c,t.node.superClass));}if(!d)return t;if(t.isClassExpression()){t.scope.push({id:e});t.replaceWith(y$1.types.assignmentExpression("=",y$1.types.cloneNode(e),t.node));}else t.node.id||(t.node.id=e);return t}}}var w$1="default"in r$6?s$5:r$6;var S$1="default"in i$2?c$2:i$2;var M$1="default"in t$7?o$9:t$7;var D$1={};Object.defineProperty(D$1,"__esModule",{value:true});D$1.buildDecoratedClass=buildDecoratedClass;D$1.hasDecorators=hasDecorators;D$1.hasOwnDecorators=hasOwnDecorators;var O=w$1;var j=S$1;var U=M$1;function hasOwnDecorators(e){return !!(e.decorators&&e.decorators.length)}function hasDecorators(e){return hasOwnDecorators(e)||e.body.body.some(hasOwnDecorators)}function prop(e,t){return t?O.types.objectProperty(O.types.identifier(e),t):null}function method(e,t){return O.types.objectMethod("method",O.types.identifier(e),[],O.types.blockStatement(t))}function takeDecorators(e){let t;e.decorators&&e.decorators.length>0&&(t=O.types.arrayExpression(e.decorators.map((e=>e.expression))));e.decorators=void 0;return t}function getKey(e){return e.computed?e.key:O.types.isIdentifier(e.key)?O.types.stringLiteral(e.key.name):O.types.stringLiteral(String(e.key.value))}function extractElementDescriptor(e,t,s){const{node:i,scope:r}=s;const a=s.isClassMethod();if(s.isPrivate())throw s.buildCodeFrameError(`Private ${a?"methods":"fields"} in decorated classes are not supported yet.`);new j.default({methodPath:s,objectRef:e,superRef:t,file:this,refToPreserve:e}).replace();const n=[prop("kind",O.types.stringLiteral(O.types.isClassMethod(i)?i.kind:"field")),prop("decorators",takeDecorators(i)),prop("static",i.static&&O.types.booleanLiteral(true)),prop("key",getKey(i))].filter(Boolean);if(O.types.isClassMethod(i)){const e=i.computed?null:i.key;O.types.toExpression(i);n.push(prop("value",(0, U.default)({node:i,id:e,scope:r})||i));}else O.types.isClassProperty(i)&&i.value?n.push(method("value",O.template.statements.ast`return ${i.value}`)):n.push(prop("value",r.buildUndefinedNode()));s.remove();return O.types.objectExpression(n)}function addDecorateHelper(e){try{return e.addHelper("decorate")}catch(e){"BABEL_HELPER_UNKNOWN"===e.code&&(e.message+="\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version.");throw e}}function buildDecoratedClass(e,t,s,i){const{node:r,scope:a}=t;const n=a.generateUidIdentifier("initialize");const o=r.id&&t.isDeclaration();const l=t.isInStrictMode();const{superClass:d}=r;r.type="ClassDeclaration";r.id||(r.id=O.types.cloneNode(e));let c;if(d){c=a.generateUidIdentifierBasedOnNode(r.superClass,"super");r.superClass=c;}const p=takeDecorators(r);const u=O.types.arrayExpression(s.filter((e=>!e.node.abstract)).map(extractElementDescriptor.bind(i,r.id,c)));const f=O.template.expression.ast`
    ${addDecorateHelper(i)}(
      ${p||O.types.nullLiteral()},
      function (${n}, ${d?O.types.cloneNode(c):null}) {
        ${r}
        return { F: ${O.types.cloneNode(r.id)}, d: ${u} };
      },
      ${d}
    )
  `;l||f.arguments[1].body.directives.push(O.types.directive(O.types.directiveLiteral("use strict")));let b=f;let m="arguments.1.body.body.0";if(o){b=O.template.statement.ast`let ${e} = ${f}`;m="declarations.0.init."+m;}return {instanceNodes:[O.template.statement.ast`${O.types.cloneNode(n)}(this)`],wrapClass(e){e.replaceWith(b);return e.get(m)}}}var L="default"in r$6?s$5:r$6;var B="default"in r$5?o$8:r$5;var A$1={};Object.defineProperty(A$1,"__esModule",{value:true});A$1.extractComputedKeys=extractComputedKeys;A$1.injectInitialization=injectInitialization$1;var R=L;var _=B;const H=R.traverse.visitors.merge([{Super(e){const{node:t,parentPath:s}=e;s.isCallExpression({callee:t})&&this.push(s);}},_.default]);const T$1={"TSTypeAnnotation|TypeAnnotation"(e){e.skip();},ReferencedIdentifier(e){if(this.scope.hasOwnBinding(e.node.name)){this.scope.rename(e.node.name);e.skip();}}};function handleClassTDZ(e,t){if(t.classBinding&&t.classBinding===e.scope.getBinding(e.node.name)){const s=t.file.addHelper("classNameTDZError");const i=R.types.callExpression(s,[R.types.stringLiteral(e.node.name)]);e.replaceWith(R.types.sequenceExpression([i,e.node]));e.skip();}}const z={ReferencedIdentifier:handleClassTDZ};function injectInitialization$1(e,t,s,i){if(!s.length)return;const r=!!e.node.superClass;if(!t){const s=R.types.classMethod("constructor",R.types.identifier("constructor"),[],R.types.blockStatement([]));if(r){s.params=[R.types.restElement(R.types.identifier("args"))];s.body.body.push(R.template.statement.ast`super(...args)`);}[t]=e.get("body").unshiftContainer("body",s);}i&&i(T$1,{scope:t.scope});if(r){const e=[];t.traverse(H,e);let i=true;for(const t of e)if(i){t.insertAfter(s);i=false;}else t.insertAfter(s.map((e=>R.types.cloneNode(e))));}else t.get("body").unshiftContainer("body",s);}function extractComputedKeys(e,t,s,i){const r=[];const a={classBinding:t.node.id&&t.scope.getBinding(t.node.id.name),file:i};for(const e of s){const s=e.get("key");s.isReferencedIdentifier()?handleClassTDZ(s,a):s.traverse(z,a);const i=e.node;if(!s.isConstantExpression()){const e=t.scope.generateUidIdentifierBasedOnNode(i.key);t.scope.push({id:e,kind:"let"});r.push(R.types.expressionStatement(R.types.assignmentExpression("=",R.types.cloneNode(e),i.key)));i.key=R.types.cloneNode(e);}}return r}var K={};Object.defineProperty(K,"__esModule",{value:true});K.FEATURES=void 0;K.enableFeature=enableFeature$1;K.isLoose=isLoose;K.verifyUsedFeatures=verifyUsedFeatures;var W=D$1;const G=Object.freeze({fields:2,privateMethods:4,decorators:8,privateIn:16,staticBlocks:32});K.FEATURES=G;const q=new Map([[G.fields,"@babel/plugin-proposal-class-properties"],[G.privateMethods,"@babel/plugin-proposal-private-methods"],[G.privateIn,"@babel/plugin-proposal-private-property-in-object"]]);const Z="@babel/plugin-class-features/featuresKey";const V$1="@babel/plugin-class-features/looseKey";const Y="@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";function enableFeature$1(e,t,s){if(!hasFeature(e,t)||canIgnoreLoose(e,t)){e.set(Z,e.get(Z)|t);if("#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error"===s){setLoose(e,t,true);e.set(Y,e.get(Y)|t);}else if("#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"===s){setLoose(e,t,false);e.set(Y,e.get(Y)|t);}else setLoose(e,t,s);}let i;let r;for(const[t,s]of q){if(!hasFeature(e,t))continue;const a=isLoose(e,t);if(!canIgnoreLoose(e,t)){if(i===!a)throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");i=a;r=s;}}if(void 0!==i)for(const[t,s]of q)if(hasFeature(e,t)&&isLoose(e,t)!==i){setLoose(e,t,i);console.warn(`Though the "loose" option was set to "${!i}" in your @babel/preset-env config, it will not be used for ${s} since the "loose" mode option was set to "${i}" for ${r}.\nThe "loose" option must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding\n\t["${s}", { "loose": ${i} }]\nto the "plugins" section of your Babel config.`);}}function hasFeature(e,t){return !!(e.get(Z)&t)}function isLoose(e,t){return !!(e.get(V$1)&t)}function setLoose(e,t,s){s?e.set(V$1,e.get(V$1)|t):e.set(V$1,e.get(V$1)&~t);e.set(Y,e.get(Y)&~t);}function canIgnoreLoose(e,t){return !!(e.get(Y)&t)}function verifyUsedFeatures(e,t){if((0, W.hasOwnDecorators)(e.node)){if(!hasFeature(t,G.decorators))throw e.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n\t["@babel/plugin-proposal-class-properties", { "loose": true }]');if(e.isPrivate())throw e.buildCodeFrameError(`Private ${e.isClassMethod()?"methods":"fields"} in decorated classes are not supported yet.`)}if(null!=e.isClassPrivateMethod&&e.isClassPrivateMethod()&&!hasFeature(t,G.privateMethods))throw e.buildCodeFrameError("Class private methods are not enabled.");if(e.isPrivateName()&&e.parentPath.isBinaryExpression({operator:"in",left:e.node})&&!hasFeature(t,G.privateIn))throw e.buildCodeFrameError("Private property in checks are not enabled.");if(e.isProperty()&&!hasFeature(t,G.fields))throw e.buildCodeFrameError("Class fields are not enabled.");if(null!=e.isStaticBlock&&e.isStaticBlock()&&!hasFeature(t,G.staticBlocks))throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.")}var J="default"in r$6?s$5:r$6;var Q="default"in t$7?o$9:t$7;var X="default"in s$6?r$7:s$6;var ee={};Object.defineProperty(ee,"__esModule",{value:true});Object.defineProperty(ee,"FEATURES",{enumerable:true,get:function(){return oe.FEATURES}});ee.createClassFeaturePlugin=createClassFeaturePlugin;Object.defineProperty(ee,"enableFeature",{enumerable:true,get:function(){return oe.enableFeature}});Object.defineProperty(ee,"injectInitialization",{enumerable:true,get:function(){return ne.injectInitialization}});var te=J;var se=Q;var ie=X;var re=m$2;var ae=D$1;var ne=A$1;var oe=K;var le=l$2;const de="7.16.7".split(".").reduce(((e,t)=>1e5*e+ +t),0);const ce="@babel/plugin-class-features/version";function createClassFeaturePlugin({name:e,feature:t,loose:s,manipulateOptions:i,api:r={assumption:()=>{}}}){const a=r.assumption("setPublicClassFields");const n=r.assumption("privateFieldsAsProperties");const o=r.assumption("constantSuper");const l=r.assumption("noDocumentAll");if(true===s){const t=[];void 0!==a&&t.push('"setPublicClassFields"');void 0!==n&&t.push('"privateFieldsAsProperties"');0!==t.length&&console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value for the ${t.join(" and ")} assumption${t.length>1?"s":""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:\n\t"assumptions": {\n\t\t"setPublicClassFields": true,\n\t\t"privateFieldsAsProperties": true\n\t}`);}return {name:e,manipulateOptions:i,pre(){(0, oe.enableFeature)(this.file,t,s);(!this.file.get(ce)||this.file.get(ce)<de)&&this.file.set(ce,de);},visitor:{Class(e,s){if(this.file.get(ce)!==de)return;(0, oe.verifyUsedFeatures)(e,this.file);e.isClassDeclaration()&&(0, le.assertFieldTransformed)(e);const i=(0, oe.isLoose)(this.file,t);let r;const d=(0, ae.hasDecorators)(e.node);const c=[];const p=[];const u=[];const f=new Set;const b=e.get("body");for(const e of b.get("body")){(0, oe.verifyUsedFeatures)(e,this.file);(e.isClassProperty()||e.isClassMethod())&&e.node.computed&&u.push(e);if(e.isPrivate()){const{name:t}=e.node.key.id;const s=`get ${t}`;const i=`set ${t}`;if(e.isClassPrivateMethod()){if("get"===e.node.kind){if(f.has(s)||f.has(t)&&!f.has(i))throw e.buildCodeFrameError("Duplicate private field");f.add(s).add(t);}else if("set"===e.node.kind){if(f.has(i)||f.has(t)&&!f.has(s))throw e.buildCodeFrameError("Duplicate private field");f.add(i).add(t);}}else {if(f.has(t)&&!f.has(s)&&!f.has(i)||f.has(t)&&(f.has(s)||f.has(i)))throw e.buildCodeFrameError("Duplicate private field");f.add(t);}}if(e.isClassMethod({kind:"constructor"}))r=e;else {p.push(e);(e.isProperty()||e.isPrivate()||null!=e.isStaticBlock&&e.isStaticBlock())&&c.push(e);}}if(!c.length&&!d)return;const m=e.node.id;let y;if(!m||e.isClassExpression()){(0, se.default)(e);y=e.scope.generateUidIdentifier("class");}else y=te.types.cloneNode(e.node.id);const h=(0, re.buildPrivateNamesMap)(c);const v=(0, re.buildPrivateNamesNodes)(h,null!=n?n:i,s);(0, re.transformPrivateNamesUsage)(y,e,h,{privateFieldsAsProperties:null!=n?n:i,noDocumentAll:l,innerBinding:m},s);let g,P,N,I,E;if(d){P=I=g=[];({instanceNodes:N,wrapClass:E}=(0, ae.buildDecoratedClass)(y,e,p,this.file));}else {g=(0, ne.extractComputedKeys)(y,e,u,this.file);({staticNodes:P,pureStaticNodes:I,instanceNodes:N,wrapClass:E}=(0, re.buildFieldsInitNodes)(y,e.node.superClass,c,h,s,null!=a?a:i,null!=n?n:i,null!=o?o:i,m));}N.length>0&&(0, ne.injectInitialization)(e,r,N,((e,t)=>{if(!d)for(const s of c)s.node.static||s.traverse(e,t);}));const F=E(e);F.insertBefore([...v,...g]);P.length>0&&F.insertAfter(P);I.length>0&&F.find((e=>e.isStatement()||e.isDeclaration())).insertAfter(I);},PrivateName(e){if(this.file.get(ce)===de&&!e.parentPath.isPrivate({key:e.node}))throw e.buildCodeFrameError(`Unknown PrivateName "${e}"`)},ExportDefaultDeclaration(e){if(this.file.get(ce)!==de)return;const t=e.get("declaration");t.isClassDeclaration()&&(0, ae.hasDecorators)(t.node)&&(t.node.id?(0, ie.default)(e):t.node.type="ClassExpression");}}}}const pe=ee.__esModule,ue=ee.FEATURES,fe=ee.enableFeature,be=ee.injectInitialization;const me=ee.createClassFeaturePlugin;

var n$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  FEATURES: ue,
  __esModule: pe,
  createClassFeaturePlugin: me,
  'default': ee,
  enableFeature: fe,
  injectInitialization: be
});

var i$1="default"in a$6?Te:a$6;var o$1="default"in r$6?s$5:r$6;var s={};Object.defineProperty(s,"__esModule",{value:true});s.default=transpileEnum;s.translateEnumValues=translateEnumValues;var l$1=i$1;var c=o$1;function transpileEnum(e,t){const{node:r}=e;if(r.declare){e.remove();return}const n=r.id.name;const a=enumFill(e,t,r.id);switch(e.parent.type){case"BlockStatement":case"ExportNamedDeclaration":case"Program":e.insertAfter(a);if(seen(e.parentPath))e.remove();else {const n=t.isProgram(e.parent);e.scope.registerDeclaration(e.replaceWith(makeVar(r.id,t,n?"var":"let"))[0]);}break;default:throw new Error(`Unexpected enum parent '${e.parent.type}`)}function seen(e){if(e.isExportDeclaration())return seen(e.parentPath);if(e.getData(n))return true;e.setData(n,true);return false}}function makeVar(e,t,r){return t.variableDeclaration(r,[t.variableDeclarator(e)])}const p$1=(0, c.template)("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");const d$1=(0, c.template)('\n  ENUM["NAME"] = VALUE;\n');const u$1=(0, c.template)('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n');const buildEnumMember=(e,t)=>(e?d$1:u$1)(t);function enumFill(e,t,r){const n=translateEnumValues(e,t);const a=n.map((([e,n])=>buildEnumMember(t.isStringLiteral(n),{ENUM:t.cloneNode(r),NAME:e,VALUE:n})));return p$1({ID:t.cloneNode(r),ASSIGNMENTS:a})}function translateEnumValues(e,t){const r=new Map;let n=-1;let a;return e.node.members.map((i=>{const o=t.isIdentifier(i.id)?i.id.name:i.id.value;const s=i.initializer;let c;if(s){n=evaluate(s,r);if(void 0!==n){r.set(o,n);if("number"===typeof n)c=t.numericLiteral(n);else {l$1("string"===typeof n);c=t.stringLiteral(n);}}else c=s;}else if("number"===typeof n){n+=1;c=t.numericLiteral(n);r.set(o,n);}else {if("string"===typeof n)throw e.buildCodeFrameError("Enum member must have initializer.");{const r=t.memberExpression(t.cloneNode(e.node.id),t.stringLiteral(a),true);c=t.binaryExpression("+",t.numericLiteral(1),r);}}a=o;return [o,c]}))}function evaluate(e,t){return evalConstant(e);function evalConstant(e){switch(e.type){case"StringLiteral":return e.value;case"UnaryExpression":return evalUnaryExpression(e);case"BinaryExpression":return evalBinaryExpression(e);case"NumericLiteral":return e.value;case"ParenthesizedExpression":return evalConstant(e.expression);case"Identifier":return t.get(e.name);case"TemplateLiteral":if(1===e.quasis.length)return e.quasis[0].value.cooked;default:return}}function evalUnaryExpression({argument:e,operator:t}){const r=evalConstant(e);if(void 0!==r)switch(t){case"+":return r;case"-":return -r;case"~":return ~r;default:return}}function evalBinaryExpression(e){const t=evalConstant(e.left);if(void 0===t)return;const r=evalConstant(e.right);if(void 0!==r)switch(e.operator){case"|":return t|r;case"&":return t&r;case">>":return t>>r;case">>>":return t>>>r;case"<<":return t<<r;case"^":return t^r;case"*":return t*r;case"/":return t/r;case"+":return t+r;case"-":return t-r;case"%":return t%r;default:return}}}var m$1={};Object.defineProperty(m$1,"__esModule",{value:true});m$1.default=transpileConstEnum;var f=s;function transpileConstEnum(e,t){const{name:r}=e.node.id;const n=e.parentPath.isExportNamedDeclaration();let a=n;!a&&t.isProgram(e.parent)&&(a=e.parent.body.some((e=>t.isExportNamedDeclaration(e)&&!e.source&&e.specifiers.some((e=>t.isExportSpecifier(e)&&e.local.name===r)))));const i=(0, f.translateEnumValues)(e,t);if(a){const a=t.objectExpression(i.map((([e,r])=>t.objectProperty(t.isValidIdentifier(e)?t.identifier(e):t.stringLiteral(e),r))));if(e.scope.hasOwnBinding(r))(n?e.parentPath:e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"),t.identifier("assign")),[e.node.id,a])));else {e.replaceWith(t.variableDeclaration("var",[t.variableDeclarator(e.node.id,a)]));e.scope.registerDeclaration(e);}return}const o=new Map(i);e.scope.path.traverse({Scope(e){e.scope.hasOwnBinding(r)&&e.skip();},MemberExpression(e){if(!t.isIdentifier(e.node.object,{name:r}))return;let n;if(e.node.computed){if(!t.isStringLiteral(e.node.property))return;n=e.node.property.value;}else {if(!t.isIdentifier(e.node.property))return;n=e.node.property.name;}o.has(n)&&e.replaceWith(t.cloneNode(o.get(n)));}});e.remove();}var y="default"in r$6?s$5:r$6;var b={};Object.defineProperty(b,"__esModule",{value:true});b.default=transpileNamespace;var g$1=y;function transpileNamespace(e,t,r){if(e.node.declare||"StringLiteral"===e.node.id.type){e.remove();return}if(!r)throw e.hub.file.buildCodeFrameError(e.node.id,"Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const n=e.node.id.name;const a=handleNested(e,t,t.cloneDeep(e.node));const i=e.scope.hasOwnBinding(n);if("ExportNamedDeclaration"===e.parent.type)if(i)e.parentPath.replaceWith(a);else {e.parentPath.insertAfter(a);e.replaceWith(getDeclaration(t,n));e.scope.registerDeclaration(e.parentPath);}else i?e.replaceWith(a):e.scope.registerDeclaration(e.replaceWithMultiple([getDeclaration(t,n),a])[0]);}function getDeclaration(e,t){return e.variableDeclaration("let",[e.variableDeclarator(e.identifier(t))])}function getMemberExpression(e,t,r){return e.memberExpression(e.identifier(t),e.identifier(r))}function handleVariableDeclaration(e,t,r){if("const"!==e.kind)throw r.file.buildCodeFrameError(e,"Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");const{declarations:n}=e;if(n.every((e=>g$1.types.isIdentifier(e.id)))){for(const e of n)e.init=g$1.types.assignmentExpression("=",getMemberExpression(g$1.types,t,e.id.name),e.init);return [e]}const a=g$1.types.getBindingIdentifiers(e);const i=[];for(const e in a)i.push(g$1.types.assignmentExpression("=",getMemberExpression(g$1.types,t,e),g$1.types.cloneNode(a[e])));return [e,g$1.types.expressionStatement(g$1.types.sequenceExpression(i))]}function buildNestedAmbiendModuleError(e,t){throw e.hub.buildError(t,"Ambient modules cannot be nested in other modules or namespaces.",Error)}function handleNested(e,t,r,n){const a=new Set;const i=r.id;t.assertIdentifier(i);const o=e.scope.generateUid(i.name);const s=t.isTSModuleBlock(r.body)?r.body.body:[t.exportNamedDeclaration(r.body)];for(let r=0;r<s.length;r++){const n=s[r];switch(n.type){case"TSModuleDeclaration":{if(!t.isIdentifier(n.id))throw buildNestedAmbiendModuleError(e,n);const i=handleNested(e,t,n);const o=n.id.name;if(a.has(o))s[r]=i;else {a.add(o);s.splice(r++,1,getDeclaration(t,o),i);}continue}case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":a.add(n.id.name);continue;case"VariableDeclaration":for(const e in t.getBindingIdentifiers(n))a.add(e);continue;default:continue;case"ExportNamedDeclaration":}switch(n.declaration.type){case"TSEnumDeclaration":case"FunctionDeclaration":case"ClassDeclaration":{const e=n.declaration.id.name;a.add(e);s.splice(r++,1,n.declaration,t.expressionStatement(t.assignmentExpression("=",getMemberExpression(t,o,e),t.identifier(e))));break}case"VariableDeclaration":{const t=handleVariableDeclaration(n.declaration,o,e.hub);s.splice(r,t.length,...t);r+=t.length-1;break}case"TSModuleDeclaration":{if(!t.isIdentifier(n.declaration.id))throw buildNestedAmbiendModuleError(e,n.declaration);const i=handleNested(e,t,n.declaration,t.identifier(o));const l=n.declaration.id.name;if(a.has(l))s[r]=i;else {a.add(l);s.splice(r++,1,getDeclaration(t,l),i);}}}}let l=t.objectExpression([]);if(n){const e=t.memberExpression(n,i);l=g$1.template.expression.ast`
      ${t.cloneNode(e)} ||
        (${t.cloneNode(e)} = ${l})
    `;}return g$1.template.statement.ast`
    (function (${t.identifier(o)}) {
      ${s}
    })(${i} || (${t.cloneNode(i)} = ${l}));
  `}var h="default"in e$1?e:e$1;var v="default"in t$5?i$5:t$5;var E="default"in r$6?s$5:r$6;var x="default"in n$1?ee:n$1;var D={};Object.defineProperty(D,"__esModule",{value:true});D.default=void 0;var T=h;var S=v;var N=E;var P=x;var w=m$1;var I=s;var M=b;function isInType(e){switch(e.parent.type){case"TSTypeReference":case"TSQualifiedName":case"TSExpressionWithTypeArguments":case"TSTypeQuery":return true;case"ExportSpecifier":return "type"===e.parentPath.parent.exportKind;default:return false}}const C=new WeakMap;const A=new WeakMap;const F=new WeakSet;function isGlobalType(e,t){const r=e.find((e=>e.isProgram())).node;if(e.scope.hasOwnBinding(t))return false;if(C.get(r).has(t))return true;console.warn(`The exported identifier "${t}" is not declared in Babel's scope tracker\nas a JavaScript value binding, and "@babel/plugin-transform-typescript"\nnever encountered it as a TypeScript type declaration.\nIt will be treated as a JavaScript value.\n\nThis problem is likely caused by another plugin injecting\n"${t}" without registering it in the scope tracker. If you are the author\n of that plugin, please use "scope.registerDeclaration(declarationPath)".`);return false}function registerGlobalType(e,t){C.get(e).add(t);}var k=(0, T.declare)(((e,t)=>{e.assertVersion(7);const r=/\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;const{allowNamespaces:n=true,jsxPragma:a="React.createElement",jsxPragmaFrag:i="React.Fragment",onlyRemoveTypeImports:o=false,optimizeConstEnums:s=false}=t;var{allowDeclareFields:l=false}=t;const c={field(e){const{node:t}=e;if(!l&&t.declare)throw e.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");if(t.declare){if(t.value)throw e.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");t.decorators||e.remove();}else if(t.definite){if(t.value)throw e.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");l||t.decorators||e.remove();}else l||t.value||t.decorators||N.types.isClassPrivateProperty(t)||e.remove();t.accessibility&&(t.accessibility=null);t.abstract&&(t.abstract=null);t.readonly&&(t.readonly=null);t.optional&&(t.optional=null);t.typeAnnotation&&(t.typeAnnotation=null);t.definite&&(t.definite=null);t.declare&&(t.declare=null);t.override&&(t.override=null);},method({node:e}){e.accessibility&&(e.accessibility=null);e.abstract&&(e.abstract=null);e.optional&&(e.optional=null);e.override&&(e.override=null);},constructor(e,t){e.node.accessibility&&(e.node.accessibility=null);const r=[];for(const t of e.node.params)if("TSParameterProperty"===t.type&&!F.has(t.parameter)){F.add(t.parameter);r.push(t.parameter);}if(r.length){const n=r.map((t=>{let r;if(N.types.isIdentifier(t))r=t;else {if(!N.types.isAssignmentPattern(t)||!N.types.isIdentifier(t.left))throw e.buildCodeFrameError("Parameter properties can not be destructuring patterns.");r=t.left;}return N.template.statement.ast`
              this.${N.types.cloneNode(r)} = ${N.types.cloneNode(r)}`}));(0, P.injectInitialization)(t,e,n);}}};return {name:"transform-typescript",inherits:S.default,visitor:{Pattern:visitPattern,Identifier:visitPattern,RestElement:visitPattern,Program:{enter(e,t){const{file:n}=t;let s=null;let l=null;const c=e.node;C.has(c)||C.set(c,new Set);if(n.ast.comments)for(const e of n.ast.comments){const t=r.exec(e.value);t&&(t[1]?l=t[2]:s=t[2]);}let p=s||a;p&&([p]=p.split("."));let d=l||i;d&&([d]=d.split("."));for(let r of e.get("body"))if(r.isImportDeclaration()){A.has(t.file.ast.program)||A.set(t.file.ast.program,true);if("type"===r.node.importKind){for(const e of r.node.specifiers)registerGlobalType(c,e.local.name);r.remove();continue}const n=new Set;const a=r.node.specifiers.length;const isAllSpecifiersElided=()=>a>0&&a===n.size;for(const e of r.node.specifiers)if("ImportSpecifier"===e.type&&"type"===e.importKind){registerGlobalType(c,e.local.name);const t=r.scope.getBinding(e.local.name);t&&n.add(t.path);}if(o)A.set(e.node,false);else {if(0===r.node.specifiers.length){A.set(e.node,false);continue}for(const t of r.node.specifiers){const a=r.scope.getBinding(t.local.name);a&&!n.has(a.path)&&(isImportTypeOnly({binding:a,programPath:e,pragmaImportName:p,pragmaFragImportName:d})?n.add(a.path):A.set(e.node,false));}}if(isAllSpecifiersElided())r.remove();else for(const e of n)e.remove();}else {r.isExportDeclaration()&&(r=r.get("declaration"));if(r.isVariableDeclaration({declare:true}))for(const e of Object.keys(r.getBindingIdentifiers()))registerGlobalType(c,e);else (r.isTSTypeAliasDeclaration()||r.isTSDeclareFunction()&&r.get("id").isIdentifier()||r.isTSInterfaceDeclaration()||r.isClassDeclaration({declare:true})||r.isTSEnumDeclaration({declare:true})||r.isTSModuleDeclaration({declare:true})&&r.get("id").isIdentifier())&&registerGlobalType(c,r.node.id.name);}},exit(e){"module"===e.node.sourceType&&A.get(e.node)&&e.pushContainer("body",N.types.exportNamedDeclaration());}},ExportNamedDeclaration(e,t){A.has(t.file.ast.program)||A.set(t.file.ast.program,true);"type"!==e.node.exportKind?e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every((e=>"ExportSpecifier"===e.type&&"type"===e.exportKind))||!e.node.source&&e.node.specifiers.length>0&&e.node.specifiers.every((t=>N.types.isExportSpecifier(t)&&isGlobalType(e,t.local.name)))?e.remove():A.set(t.file.ast.program,false):e.remove();},ExportSpecifier(e){const t=e.parent;(!t.source&&isGlobalType(e,e.node.local.name)||"type"===e.node.exportKind)&&e.remove();},ExportDefaultDeclaration(e,t){A.has(t.file.ast.program)||A.set(t.file.ast.program,true);N.types.isIdentifier(e.node.declaration)&&isGlobalType(e,e.node.declaration.name)?e.remove():A.set(t.file.ast.program,false);},TSDeclareFunction(e){e.remove();},TSDeclareMethod(e){e.remove();},VariableDeclaration(e){e.node.declare&&e.remove();},VariableDeclarator({node:e}){e.definite&&(e.definite=null);},TSIndexSignature(e){e.remove();},ClassDeclaration(e){const{node:t}=e;t.declare&&e.remove();},Class(e){const{node:t}=e;t.typeParameters&&(t.typeParameters=null);t.superTypeParameters&&(t.superTypeParameters=null);t.implements&&(t.implements=null);t.abstract&&(t.abstract=null);e.get("body.body").forEach((t=>{t.isClassMethod()||t.isClassPrivateMethod()?"constructor"===t.node.kind?c.constructor(t,e):c.method(t):(t.isClassProperty()||t.isClassPrivateProperty())&&c.field(t);}));},Function(e){const{node:t,scope:r}=e;t.typeParameters&&(t.typeParameters=null);t.returnType&&(t.returnType=null);const n=t.params;n.length>0&&N.types.isIdentifier(n[0],{name:"this"})&&n.shift();const a=e.get("params");for(const e of a)if("TSParameterProperty"===e.type){e.replaceWith(e.get("parameter"));r.registerBinding("param",e);}},TSModuleDeclaration(e){(0, M.default)(e,N.types,n);},TSInterfaceDeclaration(e){e.remove();},TSTypeAliasDeclaration(e){e.remove();},TSEnumDeclaration(e){s&&e.node.const?(0, w.default)(e,N.types):(0, I.default)(e,N.types);},TSImportEqualsDeclaration(e){if(N.types.isTSExternalModuleReference(e.node.moduleReference))throw e.buildCodeFrameError(`\`import ${e.node.id.name} = require('${e.node.moduleReference.expression.value}')\` is not supported by @babel/plugin-transform-typescript\nPlease consider using \`import ${e.node.id.name} from '${e.node.moduleReference.expression.value}';\` alongside Typescript's --allowSyntheticDefaultImports option.`);e.replaceWith(N.types.variableDeclaration("var",[N.types.variableDeclarator(e.node.id,entityNameToExpr(e.node.moduleReference))]));},TSExportAssignment(e){throw e.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\nPlease consider using `export <value>;`.")},TSTypeAssertion(e){e.replaceWith(e.node.expression);},TSAsExpression(e){let{node:t}=e;do{t=t.expression;}while(N.types.isTSAsExpression(t));e.replaceWith(t);},TSNonNullExpression(e){e.replaceWith(e.node.expression);},CallExpression(e){e.node.typeParameters=null;},OptionalCallExpression(e){e.node.typeParameters=null;},NewExpression(e){e.node.typeParameters=null;},JSXOpeningElement(e){e.node.typeParameters=null;},TaggedTemplateExpression(e){e.node.typeParameters=null;}}};function entityNameToExpr(e){return N.types.isTSQualifiedName(e)?N.types.memberExpression(entityNameToExpr(e.left),e.right):e}function visitPattern({node:e}){e.typeAnnotation&&(e.typeAnnotation=null);N.types.isIdentifier(e)&&e.optional&&(e.optional=null);}function isImportTypeOnly({binding:e,programPath:t,pragmaImportName:r,pragmaFragImportName:n}){for(const t of e.referencePaths)if(!isInType(t))return false;if(e.identifier.name!==r&&e.identifier.name!==n)return true;let a=false;t.traverse({"JSXElement|JSXFragment"(e){a=true;e.stop();}});return !a}}));D.default=k;const V=D.__esModule;

var a = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __esModule: V,
  'default': D
});

var t="default"in e$1?e:e$1;var o="default"in a?D:a;var l="default"in s$7?i$6:s$7;var i={};Object.defineProperty(i,"__esModule",{value:true});var n=t;var r=o;var u=l;function _interopDefaultLegacy(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}var m=_interopDefaultLegacy(r);const p=new u.OptionValidator("@babel/preset-typescript");function normalizeOptions(e={}){let{allowNamespaces:a=true,jsxPragma:s,onlyRemoveTypeImports:t}=e;const o={allExtensions:"allExtensions",allowNamespaces:"allowNamespaces",disallowAmbiguousJSXLike:"disallowAmbiguousJSXLike",isTSX:"isTSX",jsxPragma:"jsxPragma",jsxPragmaFrag:"jsxPragmaFrag",onlyRemoveTypeImports:"onlyRemoveTypeImports",optimizeConstEnums:"optimizeConstEnums"};const l=p.validateStringOption(o.jsxPragmaFrag,e.jsxPragmaFrag,"React.Fragment");const i=p.validateBooleanOption(o.allExtensions,e.allExtensions,false);const n=p.validateBooleanOption(o.isTSX,e.isTSX,false);n&&p.invariant(i,"isTSX:true requires allExtensions:true");const r=p.validateBooleanOption(o.disallowAmbiguousJSXLike,e.disallowAmbiguousJSXLike,false);r&&p.invariant(i,"disallowAmbiguousJSXLike:true requires allExtensions:true");const u=p.validateBooleanOption(o.optimizeConstEnums,e.optimizeConstEnums,false);return {allExtensions:i,allowNamespaces:a,disallowAmbiguousJSXLike:r,isTSX:n,jsxPragma:s,jsxPragmaFrag:l,onlyRemoveTypeImports:t,optimizeConstEnums:u}}var g=n.declare(((e,a)=>{e.assertVersion(7);const{allExtensions:s,allowNamespaces:t,disallowAmbiguousJSXLike:o,isTSX:l,jsxPragma:i,jsxPragmaFrag:n,onlyRemoveTypeImports:r,optimizeConstEnums:u}=normalizeOptions(a);const pluginOptions=(e,s)=>({allowDeclareFields:a.allowDeclareFields,allowNamespaces:t,disallowAmbiguousJSXLike:s,isTSX:e,jsxPragma:i,jsxPragmaFrag:n,onlyRemoveTypeImports:r,optimizeConstEnums:u});return {overrides:s?[{plugins:[[m.default,pluginOptions(l,o)]]}]:[{test:/\.ts$/,plugins:[[m.default,pluginOptions(false,false)]]},{test:/\.mts$/,sourceType:"module",plugins:[[m.default,pluginOptions(false,true)]]},{test:/\.cts$/,sourceType:"script",plugins:[[m.default,pluginOptions(false,true)]]},{test:/\.tsx$/,plugins:[[m.default,pluginOptions(true,false)]]}]}}));i.default=g;const d=i.__esModule;

export { d as __esModule, i as default };
